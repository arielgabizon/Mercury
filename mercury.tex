\documentclass[11pt]{article} % use larger type; default would be 10pt
\usepackage{hyperref}
\usepackage{fullpage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% packages
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={3.0},
]{doclicense}
\usepackage{authblk}
\usepackage[utf8]{inputenc} % set input encoding (not needed with xelatex)
\usepackage[strict]{changepage}
\usepackage{bold-extra}
    %%% examples of article customizations
    % these packages are optional, depending whether you want the features they provide.
    % see the latex companion or other references for full information.


    %%% page dimensions
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (us) or a5paper or....
%     \geometry{margin=2in} % for example, change the margins to 2 inches all round
    % \geometry{landscape} % set up the page for landscape
    %   read geometry.pdf for detailed page layout information
 \usepackage{numdef}

\usepackage{graphicx} % support the \includegraphics command and options
    % some of the article customisations are relevant for this class
\usepackage{amsmath,amsthm,calligra}
\usepackage{amsfonts} % math fonts such as \mathbb{}
\usepackage{amssymb} % \therefore
% \usepackage{bickham}
\usepackage{cryptocode}
\usepackage{framed}
    % \usepackage[parfill]{parskip} % activate to begin paragraphs with an empty line rather than an indent

    %%% packages
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. Enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
    % % these packages are all incorporated in the memoir class to one degree or another...
\usepackage{mathrsfs}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{adjustbox}
% \usepackage{pzccal}
% \DeclareFontFamily{OT1}{pzc}{}
% \DeclareFontShape{OT1}{pzc}{m}{it}{<-> s * [1.10] pzcmi7t}{}
% \DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}
\usepackage{pgfplots}

\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}

    %%% headers & footers
\usepackage{fancyhdr} % this should be set after setting up the page geometry
\pagestyle{fancy} % options: empty, plain, fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}


    %%% section title appearance
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (see the fntguide.pdf for font help)
    % (this matches context defaults)

    %%% toc (table of contents) appearance
\usepackage[nottoc,notlof,notlot]{tocbibind} % put the bibliography in the toc
\usepackage[titles,subfigure]{tocloft} % alter the style of the table of contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % no bold!
\usepackage[scr=esstix]  % heavily sloped
%             cal=esstix]   % slightly sloped
           {mathalpha}
 %%% end article customizations

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % macros
 \newcommand{\code}[1]{\texttt{#1}}
\newcommand\tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\newcommand\bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut
\newcommand{\bgamma}{\boldsymbol{\gamma}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
\newcommand{\plonk}{\ensuremath{\mathcal{P} \mathfrak{lon}\mathcal{K}}\xspace}
\newcommand{\gemini}{\ensuremath{\mathsf{gemini}}\xspace}
\newcommand{\zeromorph}{\ensuremath{\mathsf{zeromorph}}\xspace}
\newcommand{\mercury}{\ensuremath{\mathpgoth{MERCURY} }\xspace}
\newcommand{\cq}{\ensuremath{\mathpgoth{cq}}\xspace}
\newcommand{\cqlin}{\ensuremath{\mathpgoth{cq}\mathscr{\text{\calligra{lin}}}}\xspace}
\newcommand{\cqstar}{\ensuremath{\mathpgoth{cq^{\mathbf{*}}}}\xspace}
\newcommand{\protogal}{{\normalfont\scshape Proto\bfseries{galaxy}}\xspace}
\newcommand{\stackproofs}{s{\ensuremath{\mathfrak{t} \mathpgoth {ack}}\bfseries{proofs}}\xspace}
\newcommand{\protostar}{{\scshape Protostar}\xspace}
\newcommand{\hypernova}{{HyperNova}\xspace}
\newcommand{\flookup}{\ensuremath{\mathsf{\mathpgoth{Flookup}}}\xspace}
\newcommand{\baloo}{\ensuremath{\mathrm{ba}\mathit{loo}}\xspace}
\newcommand{\caulkp}{\ensuremath{\mathsf{\mathrel{Caulk}\mathrel{\scriptstyle{+}}}}\xspace}
\newcommand{\caulk}{\ensuremath{\mathsf{Caulk}}\xspace}
\newcommand{\plookup}{\ensuremath{\mathpgoth{plookup}}\xspace}
\newcommand{\tablegroup}{\ensuremath{\mathbb{H}}\xspace}
\newcommand{\V}{\ensuremath{\mathbf{V}}\xspace}
\newcommand{\relbase}{\ensuremath{\rel_0}\xspace}
\mathchardef\mhyphen="2D


\newcommand{\instbase}{\ensuremath{\inst_0}\xspace}
\newcommand{\witbase}{\ensuremath{\wit_0}\xspace}


\newcommand{\papertitle}{\mercury: A multilinear Polynomial Commitment Scheme with constant proof size and no prover FFTs}

\newcommand{\company}{}
\title{ \bf \papertitle \\[0.72cm]}
\author{ Liam Eagen \\ \tt{Alpen Labs}   \and Ariel Gabizon \\ \tt{Aztec Labs} } 
% \author{
%     Liam Eagen \\ {\small \texttt{Alpen Labs}} 
%     \and 
%     Ariel Gabizon \\ {\small \texttt{Aztec Labs}}
% }
% \author{
%     \hspace[.5\linewidth]{Liam Eagen \\ \tt{Alpen Labs}}
%     \and
%     \hspace[.5\linewidth]{Ariel Gabizon \\ \tt{Aztec Labs}}
% }
% \author{
%     \begin{minipage}{0.45\textwidth}
%         \centering
%         Liam Eagen \\
%         \tt{Alpen Labs}
%     \end{minipage}
%     \hfill
%     \begin{minipage}{0.45\textwidth}
%         \centering
%         Ariel Gabizon \\
%         \tt{Aztec Labs}
%     \end{minipage}
% }

% otherwise the current date is printed
\DeclareMathAlphabet{\mathpgoth}{OT1}{pgoth}{m}{n}
\ProvidesPackage{numdef}



%% Ariel Macros:
% \num\newcommand{\G1}{\ensuremath{{\mathbb G}_1}\xspace}
\newcommand{\Gi}{\ensuremath{{\mathbb G}_i}\xspace}
\newcommand{\G}{\ensuremath{{\mathbb G}}\xspace}
\newcommand{\Gtwo}{\ensuremath{{\mathbb G}_2}\xspace}
\newcommand{\Gstar}{\ensuremath{{\mathbb G}^*}\xspace}
\newcommand{\x}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\z}{\ensuremath{\mathbf{z}}\xspace}
\newcommand{\X}{\ensuremath{\mathbf{X}}\xspace}

% \num\newcommand{\G2}{\ensuremath{{\mathbb G}_2}\xspace}
%\num\newcommand{\G11}{\ensuremath{\G1\setminus \set{0}}\xspace}
%\num\newcommand{\G21}{\ensuremath{\G2\setminus \set{0}}\xspace}
\newcommand{\grouppair}{\ensuremath{G^*}\xspace}
\newcommand{\prvperm}{\ensuremath{\mathrm{P_{\mathsf{\sigma}}}}\xspace}
\newcommand{\verperm}{\ensuremath{\mathrm{V_{\mathsf{\sigma}}}}\xspace}
\newcommand{\alg}{\ensuremath{\mathscr{A}}\xspace}

\newcommand{\Gt}{\ensuremath{{\mathbb G}_t}\xspace}
\newcommand{\F}{\ensuremath{\mathbb F}\xspace}
\newcommand{\Fstar}{\ensuremath{\mathbb F^*}\xspace}

\newcommand{\help}[1]{$#1$-helper\xspace}
\newcommand{\randompair}[1]{\ensuremath{\mathsf{randomPair}(#1)}\xspace}
\newcommand{\pair}[1]{$#1$-pair\xspace}
\newcommand{\pairs}[1]{$#1$-pairs\xspace}
\newcommand{\chalpoint}{\ensuremath{\mathfrak{z}}\xspace}

% \newcommand{\pairone}[1]{\G1-$#1$-pair\xspace}
% \newcommand{\pairtwo}[1]{\G2-$#1$-pair\xspace}
% \newcommand{\sameratio}[2]{\ensuremath{\mathsf{SameRatio}(#1,#2)}\xspace}
\newcommand{\vecc}[2]{\ensuremath{\left(#1\right)_{#2}}\xspace}
\newcommand{\players}{\ensuremath{[n]}\xspace}
\newcommand{\adv}{\ensuremath{\mathcal A}\xspace}
\newcommand{\advprime}{\ensuremath{\mathcal{A}'}\xspace}
\newcommand{\extprime}{\ensuremath{E'}\xspace}
\newcommand{\advrand}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
% \num\newcommand{\srs1}{\ensuremath{\mathsf{srs_1}}\xspace}
% \num\newcommand{\srs2}{\ensuremath{\mathsf{srs_2}}\xspace}
\newcommand{\srs}{\ensuremath{\mathsf{srs}}\xspace}
\newcommand{\regsrs}[1]{\ensuremath{\sett{\enc1{x^i}}{i\in \set{0,\ldots,#1-1}}}\xspace}
\newcommand{\srsm}{\ensuremath{\mathsf{srs}_M}\xspace}
\newcommand{\ext}{\ensuremath{\mathcal{E}}\xspace}
\newcommand{\srsbase}{\ensuremath{\mathsf{srs_0}}\xspace}
\newcommand{\srsi}{\ensuremath{\mathsf{srs_i}}\xspace}
\newcommand{\com}{\ensuremath{\mathsf{com}}\xspace}
\newcommand{\comperm}{\ensuremath{\mathsf{com_{\sigma}}}\xspace}
\newcommand{\cm}{\ensuremath{\mathsf{cm}}\xspace}
\newcommand{\cmsig}{\ensuremath{\mathsf{cm_\sigma}}\xspace}
\newcommand{\open}{\ensuremath{\mathsf{open}}\xspace}
\newcommand{\openperm}{\ensuremath{\mathsf{open_{\sigma}}}\xspace}
\newcommand{\sigof}[1]{\ensuremath{\sigma(#1)}\xspace}
\newcommand{\proverexp}{\ensuremath{\mathsf{e}}\xspace}
\newcommand{\reducedelems}{\ensuremath{\mathsf{r}}\xspace}

\newcommand{\ci}{\ensuremath{\mathrm{CI}}\xspace}
\renewcommand{\deg}{\ensuremath{\mathrm{deg}}\xspace}
\newcommand{\pairvec}[1]{$#1$-vector\xspace}
\newcommand{\Fq}{\ensuremath{\mathbb{F}_q}\xspace}
\newcommand{\randpair}[1]{\ensuremath{\mathsf{rp}_{#1}}\xspace}
\newcommand{\randpairone}[1]{\ensuremath{\mathsf{rp}_{#1}^{1}}\xspace}
\newcommand{\negl}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\randpairtwo}[1]{\ensuremath{\mathsf{rp_{#1}^2}}\xspace}%the randpair in G2
% \newcommand{\nilp}{\ensuremath{\mathscr N}\xspace}
% \newcommand{\groupgen}{\ensuremath{\mathscr G}\xspace}
% \newcommand{\qap}{\ensuremath{\mathscr Q}\xspace}
\newcommand{\polprot}[4]{$(#1,#2,#3,#4)$-polynomial protocol}
\newcommand{\rangedprot}[5]{$#5$-ranged $(#1,#2,#3,#4)$-polynomial protocol}

\newcommand{\rej}{\shlomomath{reject}}
\newcommand{\accept}{\ensuremath{\mathsf{accept}}\xspace}
\newcommand{\res}{\ensuremath{\mathsf{res}}\xspace}
% \newcommand{\sha}[1]{\ensuremath{\mathsf{COMMIT}(#1)}\xspace}
%  \newcommand{\shaa}{\ensuremath{\mathsf{COMMIT}}\xspace}
 \newcommand{\comm}[1]{\ensuremath{\enc1{#1(x)}}\xspace}
 \newcommand{\defeq}{:=}

\newcommand{\dom}{\ensuremath{H}\xspace}
\newcommand{\C}{\ensuremath{\vec{C}}\xspace}
\newcommand{\randadv}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
 \num\newcommand{\ex1}[1]{\ensuremath{#1\cdot g_1}\xspace}
 \num\newcommand{\ex2}[1]{\ensuremath{#1\cdot g_2}\xspace}
 \newcommand{\pr}{\mathrm{Pr}}
%  \newcommand{\powervec}[2]{\ensuremath{(1,#1,#1^{2},\ldots,#1^{#2})}\xspace}
%  \newcommand{\partition}{\ensuremath{\mathcal{T}}\xspace}
%  \newcommand{\partof}[1]{\ensuremath{{\partition_{#1}}}\xspace}
% \num\newcommand{\out1}[1]{\ensuremath{\ex1{\powervec{#1}{d}}}\xspace}
% \num\newcommand{\out2}[1]{\ensuremath{\ex2{\powervec{#1}{d}}}\xspace}
%  \newcommand{\nizk}[2]{\ensuremath{\mathrm{NIZK}(#1,#2)}\xspace}% #2 is the hash concatenation input
%  \newcommand{\verifynizk}[3]{\ensuremath{\mathrm{VERIFY\mhyphen NIZK}(#1,#2,#3)}\xspace}
\newcommand{\protver}{protocol verifier\xspace}
\newcommand{\hash}{\ensuremath{\mathcal{H}}\xspace}
\newcommand{\mulgroup}{\ensuremath{\F^*}\xspace}
\newcommand{\lag}[1]{\ensuremath{L_{#1}}\xspace}
\newcommand{\sett}[2]{\ensuremath{\set{#1}_{#2}}\xspace}
\newcommand{\omegaprod}{\ensuremath{\alpha_{\omega}}\xspace}
\newcommand{\lagvec}[1]{\ensuremath{\mathrm{LAG}_{#1}}\xspace}
\newcommand{\trapdoor}{\ensuremath{r}}
\newcommand{\trapdoorext}{\ensuremath{r_{\mathrm{ext}}}\xspace}
% \newcommand{\trapdoorsim}{\ensuremath{r_{\mathrm{sim}}}\xspace}
\renewcommand{\sim}{\ensuremath{\mathrm{S}}\xspace}
\renewcommand{\mod}{\ensuremath{\;\mathrm{mod}\;}}
\newcommand{\hsub}{\ensuremath{H^*}\xspace}
% \num\newcommand{\enc1}[1]{\ensuremath{\left[#1\right]_1}\xspace}
\newcommand{\enci}[1]{\ensuremath{\left[#1\right]_i}\xspace}
% \num\newcommand{\enc2}[1]{\ensuremath{\left[#1\right]_2}\xspace}

\newcommand{\enc}[1]{\ensuremath{\left[#1\right]}\xspace}
\newcommand{\enctwo}[1]{\ensuremath{\left[#1\right]_2}\xspace}
\newcommand{\gen}{\ensuremath{\mathsf{gen}}\xspace}
\newcommand{\gops}{\G1-operations\xspace}
\newcommand{\nlogngops}{$O(n\log n)$ \G1-operations\xspace}
\newcommand{\nlognfops}{$O(n\log n)$ \F-operations\xspace}
\newcommand{\fops}{\F-operations\xspace}
\newcommand{\prv}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\prvpoly}{\ensuremath{\mathrm{P_{\mathsf{poly}}}}\xspace}
\newcommand{\prvpc}{\ensuremath{\mathrm{P_{\mathsf{PC}}}}\xspace}
\newcommand{\verpoly}{\ensuremath{\mathrm{V_{\mathsf{poly}}}}\xspace}
\newcommand{\verpc}{\ensuremath{\mathrm{V_{\mathsf{PC}}}}\xspace}
\newcommand{\ideal}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\prf}{\ensuremath{\mathsf{\pi}}\xspace}
\newcommand{\prfone}{\ensuremath{\mathsf{\pi_1}}\xspace}
% \newcommand{\simprv}{\ensuremath{\mathrm{P^{sim}}}\xspace}

%\newcommand{\enc}[1]{\ensuremath{\left[#1\right]}\xspace}
%\num\newcommand{\G0}{\ensuremath{\mathbf{G}}\xspace}
\newcommand{\GG}{\ensuremath{\mathbf{G^*}}\xspace}  % would have liked to call this G01 but problem with name
\num\newcommand{\g0}{\ensuremath{\mathbf{g}}\xspace}
\newcommand{\inst}{\ensuremath{\phi}\xspace}
\newcommand{\newinst}{\ensuremath{\phi^*}\xspace}
\newcommand{\row}{\ensuremath{\mathsf{R}}\xspace}
\newcommand{\col}{\ensuremath{\mathsf{C}}\xspace}
\newcommand{\inp}{\ensuremath{\mathsf{x}}\xspace}
\newcommand{\wit}{\ensuremath{\mathsf{\omega}}\xspace}
\newcommand{\eps}{\ensuremath{\varepsilon}\xspace}
\newcommand{\inpF}{\ensuremath{\mathscr{x}}\xspace}
\newcommand{\witF}{\ensuremath{\mathscr{w}}\xspace}
\newcommand{\instFprime}{\ensuremath{\inst}\xspace}%\mathpgoth{x}}\xspace}
\newcommand{\witFprime}{\ensuremath{\witinst}\xspace}%\mathpgoth{w}}\xspace}
\newcommand{\acchash}{\ensuremath{\mathscr{h}}\xspace}
\newcommand{\accnew}{\ensuremath{\mathscr{acc}}\xspace}
\newcommand{\cnt}{\ensuremath{\mathsf{count}}\xspace}
\newcommand{\ver}{\ensuremath{\mathsf{\mathbf{V}}}\xspace}
\newcommand{\verpg}{\ensuremath{\ver^{\predinst,\cm}_{PG}}\xspace}
\newcommand{\per}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\perpg}{\ensuremath{\per_{PG}}\xspace}
\newcommand{\sonic}{\ensuremath{\mathsf{Sonic}}\xspace}
\newcommand{\aurora}{\ensuremath{\mathsf{Aurora}}\xspace}
\newcommand{\auroralight}{\ensuremath{\mathsf{Auroralight}}\xspace}
\newcommand{\groth}{\ensuremath{\mathsf{Groth'16}}\xspace}
\newcommand{\kate}{\ensuremath{\mathsf{KZG}}\xspace}
\newcommand{\rel}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\relrand}{\ensuremath{\mathcal{R^{\mathsf{rand}}}}\xspace}
\newcommand{\lang}{\ensuremath{\mathcal{L}}\xspace}
\newcommand{\params}{\ensuremath{\mathsf{params}_{\inst}}\xspace}
\newcommand{\protparams}{\ensuremath{\mathsf{params}_{\inst}^\advv}\xspace}
\num\newcommand{\p1}{\ensuremath{P_1}\xspace}
\newcommand{\advv}{\ensuremath{\mathcal{A}^{\mathbf{*}}}\xspace} % the adversary that uses protocol adversary as black box
\newcommand{\crs}{\ensuremath{\sigma}\xspace}
%\num\newcommand{\crs1}{\ensuremath{\mathrm{\sigma}_1}\xspace}
%\num\newcommand{\crs2}{\ensuremath{\mathrm{\sigma}_2}\xspace}
\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace}
% \newcommand{\hgen}{\ensuremath{\mathbf{\omega}}\xspace}
\newcommand{\vgen}{\ensuremath{\mathbf{g}}\xspace}
% \renewcommand{\sim}{\ensuremath{\mathsf{sim}}\xspace}%the distribution of messages when \advv simulates message of \p1
\newcommand{\real}{\ensuremath{\mathsf{real}}\xspace}%the distribution of messages when \p1 is honest and \adv controls rest of players
 \newcommand{\koevec}[2]{\ensuremath{(1,#1,\ldots,#1^{#2},\alpha,\alpha #1,\ldots,\alpha #1^{#2})}\xspace}
\newcommand{\mida}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\midb}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\midc}{\ensuremath{C_{\mathrm{mid}}}\xspace}
\newcommand{\chal}{\ensuremath{\mathsf{challenge}}\xspace}
\newcommand{\attackparams}{\ensuremath{\mathsf{params^{pin}}}\xspace}
\newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\attackdist}[2]{\ensuremath{AD_{#1}}\xspace}
% \renewcommand{\neg}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\ro}{\ensuremath{{\mathscr R}}\xspace}
\newcommand{\elements}[1]{\ensuremath{\mathsf{elements}_{#1}}\xspace}
 \num\newcommand{\elmpowers1}[1]{\ensuremath{\mathrm{\mathsf{e}}^1_{#1}}\xspace}
 \num\newcommand{\elmpowers2}[1]{\ensuremath{\mathrm{\mathsf{e}}^2_{#1}}\xspace}
\newcommand{\elempowrs}[1]{\ensuremath{\mathsf{e}_{#1}}\xspace}
 \newcommand{\secrets}{\ensuremath{\mathsf{secrets}}\xspace}
 \newcommand{\polysofdeg}[1]{\ensuremath{\F_{< #1}[X]}\xspace}
 \newcommand{\polysofdegeq}[1]{\ensuremath{\F_{\leq #1}[X]}\xspace}
 \newcommand{\polys}{\ensuremath{\F[X]}\xspace}
 \newcommand{\bivar}[1]{\ensuremath{\F_{< #1}[X,Y]}\xspace}
 \newcommand{\sig}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\prot}{\ensuremath{\mathscr{P}}\xspace}
 \newcommand{\protstar}{\ensuremath{\mathscr{P}^*}\xspace}
 \newcommand{\PCscheme}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\protprime}{\ensuremath{\mathscr{P^*}}\xspace}
 \newcommand{\sigprv}{\ensuremath{\mathsf{P_{sc}}}\xspace}
 \newcommand{\sigver}{\ensuremath{\mathsf{V_{sc}}}\xspace}
 \newcommand{\sigpoly}{\ensuremath{\mathsf{S_{\sigma}}}\xspace}
 \newcommand{\idpoly}{\ensuremath{\mathsf{S_{ID}}}\xspace}
\newcommand{\idpolyevala}{\ensuremath{\mathsf{\bar{s}_{ID1}}}\xspace}
\newcommand{\sigpolyevala}{\ensuremath{\mathsf{\bar{s}_{\sigma1}}}\xspace}
\newcommand{\sigpolyevalb}{\ensuremath{\mathsf{\bar{s}_{\sigma2}}}\xspace}
\newcommand{\bctv}{\ensuremath{\mathsf{BCTV}}\xspace}
\newcommand{\PI}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\PIb}{\ensuremath{\mathsf{PI_B}}\xspace}
\newcommand{\PIc}{\ensuremath{\mathsf{PI_C}}\xspace}
\newcommand{\dl}[1]{\ensuremath{\widehat{#1}}\xspace}
\newcommand{\obgen}{\ensuremath{\mathcal O}\xspace}
\newcommand{\PC}{\ensuremath{\mathscr{P}}\xspace}
\newcommand{\permscheme}{\ensuremath{\sigma_\mathscr{P}}\xspace}


\newcommand{\selleft}{\ensuremath{\mathbf{q_L}}\xspace}
\newcommand{\selright}{\ensuremath{\mathbf{q_R}}\xspace}
\newcommand{\selout}{\ensuremath{\mathbf{q_O}}\xspace}
\newcommand{\selmult}{\ensuremath{\mathbf{q_M}}\xspace}
\newcommand{\selconst}{\ensuremath{\mathbf{q_C}}\xspace}
\newcommand{\selectors}{\ensuremath{\mathcal{Q}}\xspace}
\newcommand{\lvar}{\ensuremath{\mathbf{a}}\xspace}
\newcommand{\vars}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\rvar}{\ensuremath{\mathbf{b}}\xspace}
\newcommand{\ovar}{\ensuremath{\mathbf{c}}\xspace}
\newcommand{\pubvars}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\assignment}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\constsystem}{\ensuremath{\mathscr{C}}\xspace}
\newcommand{\relof}[1]{\ensuremath{\rel_{#1}}\xspace}
\newcommand{\pubinppoly}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\sumi}[1]{\sum_{i< #1}}
\newcommand{\sumzertok}[1]{\sum_{#1=0}^{k}}
\newcommand{\sumpoly}[1]{\sum_{i=0}^{#1-1}}
\newcommand{\summ}[1]{\sum_{i\in[#1]}}
\newcommand{\sumj}[1]{\sum_{j< #1}}
\newcommand{\innerprod}[2]{\langle#1,#2\rangle}
\newcommand{\ZeroH}{\ensuremath{Z_H} \xspace}
\newcommand{\lpoly}{\ensuremath{\mathsf{a}}\xspace}
\newcommand{\rpoly}{\ensuremath{\mathsf{b}}\xspace}
\newcommand{\opoly}{\ensuremath{\mathsf{c}}\xspace}
\newcommand{\idpermpoly}{\ensuremath{\mathsf{z}}\xspace}
\newcommand{\lagrangepoly}{\ensuremath{\mathsf{L}}\xspace}
\newcommand{\zeropoly}{\ensuremath{\mathsf{\ZeroH}}\xspace}
\newcommand{\selmultpoly}{\ensuremath{\mathsf{q_M}}\xspace}
\newcommand{\selleftpoly}{\ensuremath{\mathsf{q_L}}\xspace}
\newcommand{\selrightpoly}{\ensuremath{\mathsf{q_R}}\xspace}
\newcommand{\seloutpoly}{\ensuremath{\mathsf{q_O}}\xspace}
\newcommand{\selconstpoly}{\ensuremath{\mathsf{q_C}}\xspace}
\newcommand{\idcomm}{\ensuremath{[s_{\mathsf{ID1}}]_1}\xspace}
\newcommand{\sigcomma}{\ensuremath{[s_{\mathsf{\sigma1}}]_1}\xspace}
\newcommand{\sigcommb}{\ensuremath{[s_{\mathsf{\sigma2}}]_1}\xspace}
\newcommand{\sigcommc}{\ensuremath{[s_{\mathsf{\sigma3}}]_1}\xspace}
\newcommand{\selleftcomm}{\ensuremath{[q_\mathsf{L}]_1}\xspace}
\newcommand{\selrightcomm}{\ensuremath{[q_\mathsf{R}]_1}\xspace}
\newcommand{\seloutcomm}{\ensuremath{[q_\mathsf{O}]_1}\xspace}
\newcommand{\selconstcomm}{\ensuremath{[q_\mathsf{C}]_1}\xspace}
\newcommand{\selmultcomm}{\ensuremath{[q_\mathsf{M}]_1}\xspace}

\newcommand{\multlinecomment}[1]{\directlua{-- #1}}


\newtheorem{lemma}{Lemma}[section]
\newtheorem{thm}[lemma]{Theorem}
\newtheorem{dfn}[lemma]{Definition}
\newtheorem{remark}[lemma]{Remark}

\newtheorem{claim}[lemma]{Claim}
\newtheorem{corollary}[lemma]{Corollary}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\crct}{\ensuremath{\mathsf{C}}\xspace}
\newcommand{\A}{\ensuremath{\mathcal{A}}\xspace}
%\newcommand{\G}{\mathcal{G}}
\newcommand{\Gr}{\mathbb{G}}
%\newcommand{\com}{\textsf{com}}  Ariel defined equivalent that also works in math mode
\newcommand{\cgen}{\text{cgen}}
\newcommand{\poly}{\ensuremath{\mathsf{poly(\lambda)}}\xspace}
\newcommand{\snark}{\ensuremath{\mathsf{snark}}\xspace}
\newcommand{\grandprod}{\mathsf{prod}}
\newcommand{\perm}{\mathsf{S}}
%\newcommand{\open}{\mathsf{open}}
\newcommand{\update}{\mathsf{update}}
\newcommand{\Prove}{\mathcal{P}}
\newcommand{\Verify}{\mathcal{V}}
\newcommand{\Extract}{\mathcal{E}}
\newcommand{\Simulate}{\mathcal{S}}
\newcommand{\Unique}{\mathcal{U}}
\newcommand{\Rpoly}{\R{\poly}}
\newcommand{\Ppoly}{\Prove{\poly}}
\newcommand{\Vpoly}{\Verify{\poly}}
\newcommand{\Psnark}{\prv}%{\Prove{\snark}}
\newcommand{\Vsnark}{\ver}%{\Verify{\snark}}
\newcommand{\Rprod}{\R{\grandprod}}
\newcommand{\Pprod}{\Prove{\grandprod}}
\newcommand{\Vprod}{\Verify{\grandprod}}
\newcommand{\Rperm}{\R{\perm}}
\newcommand{\Pperm}{\Prove{\perm}}
\newcommand{\Vperm}{\Verify{\perm}}
% \newcommand{\zw}[1]{{\textcolor{magenta}{Zac:#1}}}
\newcommand{\ag}[1]{{\textcolor{blue}{\emph{Ariel:#1}}}}
\newcommand{\extprot}{\ensuremath{E_{\prot}}\xspace}
\newcommand{\transcript}{\ensuremath{\mathsf{transcript}}\xspace}
\newcommand{\extpc}{\ensuremath{E_{\PCscheme}}\xspace}
\newcommand{\advpc}{\ensuremath{\mathcal A_{\PCscheme}}\xspace}
\newcommand{\advprot}{\ensuremath{\mathcal A_{\prot}}\xspace}
\newcommand{\protmany}{\ensuremath{\prot_k}\xspace}

\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\marlin}{\ensuremath{\mathsf{Marlin}}\xspace}
\newcommand{\fractal}{\ensuremath{\mathsf{Fractal}}\xspace}
% \newcommand{\Rsnark}{\R{\snark}}
\newcommand{\Rsnark}{\R}
\newcommand{\subvec}[1]{\ensuremath{#1|_{\subspace}}\xspace}
\newcommand{\restricttovec}[1]{\ensuremath{#1|_{\subgroup}}\xspace}
\newcommand{\isinvanishing}[1]{\ensuremath{\mathsf{IsInVanishing_{\subspace,#1}}}\xspace}
\newcommand{\batchedisinvanishing}[1]{\ensuremath{\mathsf{BatchedIsInVanishing_{\subspace,#1}}}\xspace}
\newcommand{\isconsistent}{\ensuremath{\mathsf{IsConsistent}}\xspace}
\newcommand{\isintable}{\ensuremath{\mathsf{IsInTable}}\xspace}
\newcommand{\lincheck}{\ensuremath{\mathsf {lincheck}}\xspace}
\newcommand{\accprot}{\ensuremath{\mathsf {accProt}}\xspace}
\newcommand{\isinvanishingtable}[1]{\ensuremath{\mathsf{IsInVanishingTable_{\subspace,#1}}}\xspace}
\newcommand{\isvanishingsubtable}[1]{\ensuremath{\mathsf{IsVanishingSubtable_{#1}}}\xspace}
\newcommand{\haslowerdegree}{\ensuremath{\mathsf{HasLowerDegree}}\xspace}
\newcommand{\haslowdegree}[1]{\ensuremath{\mathsf{HasLowDegree_{#1}}}\xspace}
\newcommand{\issubtable}[1]{\ensuremath{\mathsf{IsSubtable_{#1}}}\xspace}
\newcommand{\isinsubtable}[2]{\ensuremath{\mathsf{IsInSubtable_{#1,#2}}}\xspace}
\newcommand{\secbasezero}[1]{\ensuremath{\hat{\tau}_{#1}}\xspace}
\newcommand{\secbase}[1]{\ensuremath{\hat{\tau}_{#1}}\xspace}
\newcommand{\secbasereg}[1]{\ensuremath{\tau_{#1}}\xspace}
\newcommand{\secset}{\ensuremath{I}\xspace}
\newcommand{\pubbase}[1]{\ensuremath{\mu_{#1}}\xspace}
\newcommand{\subspace}{\ensuremath{\mathbb{H}}\xspace}
\newcommand{\subgroup}{\ensuremath{\mathbb{H}}\xspace}
\newcommand{\biggroup}{\ensuremath{\mathbb{V}}\xspace}
\newcommand{\subtable}{\ensuremath{T_0}\xspace}
\newcommand{\tablelang}{\ensuremath{\lang_T}\xspace}
\newcommand{\vanishingtablelang}{\ensuremath{\lang_{\subspace}}\xspace}
\newcommand{\nonorm}[1]{\ensuremath{\Gamma^T_{#1}}\xspace}
\newcommand{\unnorm}[2]{\ensuremath{\Gamma^{#1}_{#2}}\xspace}
\newcommand{\bigspacebase}{\ensuremath{\lambda}\xspace}
\newcommand{\bigspacegen}{\ensuremath{\mathsf{h}}\xspace}
\newcommand{\modvan}[1]{\ensuremath{\mathrm{mod\;}Z_{#1}}\xspace}
\newcommand{\extractevaltable}{\ensuremath{\mathsf{ExtractEvalTable}_{C,\tablegroup}}\xspace}
\newcommand{\witsize}{\ensuremath{n}\xspace}
\newcommand{\witruntime}{\ensuremath{\witsize\log\witsize}\xspace}
\newcommand{\tabsize}{\ensuremath{N}\xspace}
\newcommand{\tabruntime}{\ensuremath{\tabsize\log\tabsize}\xspace}
\newcommand{\tab}{\ensuremath{\mathfrak{t}}\xspace}
 \renewcommand{\a}{\ensuremath{\mathsf{a}}\xspace}
\renewcommand{\b}{\ensuremath{\mathsf{b}_0}\xspace}
\renewcommand{\c}{\ensuremath{\mathsf{c}}\xspace}
\newcommand{\vc}{\ensuremath{\mathsf{c_v}}\xspace}
\renewcommand{\v}{\ensuremath{\mathsf{v}}\xspace}
\renewcommand{\r}{\ensuremath{\mathsf{r}}\xspace}
\newcommand{\h}{\ensuremath{\mathsf{h}}\xspace}
\renewcommand{\d}{\ensuremath{\mathsf{d}}\xspace}
\newcommand{\f}{\ensuremath{\mathsf{f}}\xspace}
\renewcommand{\g}{\ensuremath{\mathsf{g}}\xspace}
\newcommand{\matrices}{\ensuremath{\F^{n\times n}}\xspace}
\newcommand{\ftwo}{\ensuremath{\mathsf{f}_2}\xspace}
\renewcommand{\p}{\ensuremath{\mathsf{p}}\xspace}
\newcommand{\q}{\ensuremath{\mathsf{q}}\xspace}
\newcommand{\qone}{\ensuremath{\mathsf{q_1}}\xspace}
\newcommand{\s}{\ensuremath{\mathsf{s}}\xspace}
\newcommand{\qa}{\ensuremath{\mathsf{q_a}}\xspace}
\newcommand{\qb}{\ensuremath{\mathsf{q_b}}\xspace}
\newcommand{\m}{\ensuremath{\mathsf{m}}\xspace}
\newcommand{\agam}{\ensuremath{a_\gamma}\xspace}
\newcommand{\gamproof}{\ensuremath{\mathsf{\pi_\gamma}}\xspace}
\newcommand{\zerproof}{\ensuremath{\mathsf{\a}_0}\xspace}
\newcommand{\bgam}{\ensuremath{b_\gamma}\xspace}
\newcommand{\bzergam}{\ensuremath{b_{0,\gamma}}\xspace}
\newcommand{\qbgam}{\ensuremath{Q_{b,\gamma}}\xspace}
\newcommand{\zgam}{\ensuremath{Z_{\bigspace,\gamma}}\xspace}
\newcommand{\betaa}{\ensuremath{\mathbf{\boldsymbol{\beta}}}\xspace}
\newcommand{\deltaa}{\ensuremath{\mathbf{\boldsymbol{\delta}}}\xspace}
\newcommand{\gammaa}{\ensuremath{\mathbf{\boldsymbol{\gamma}}}\xspace}
\newcommand{\witcom}{\ensuremath{\mathsf{W}}\xspace}
\newcommand{\instt}{\ensuremath{\Phi^*}\xspace}
\newcommand{\insttbase}{\ensuremath{\Phi}\xspace}
\newcommand{\pow}{\ensuremath{\mathsf{pow}}\xspace}
\newcommand{\eq}{\ensuremath{\mathsf{eq}}\xspace}
\newcommand{\FFT}{\ensuremath{\mathsf{FFT}}\xspace}
\newcommand{\fgam}{\ensuremath{f_{\gamma}}\xspace}
\newcommand{\pgam}{\ensuremath{P_{\gamma}}\xspace}
\newcommand{\supp}[1]{\ensuremath{\mathrm{supp}(#1)}\xspace}
\newcommand{\degoffset}{\ensuremath{\tabsize-1-(\witsize-2)}\xspace}
\newcommand{\modpoly}[1]{\ensuremath{\;\;\mod #1(X)}\xspace}
\newcommand{\coeff}[2]{\ensuremath{(#1)_{[#2]}}\xspace}
\newcommand{\kzg}[1]{\ensuremath{\mathsf{KZG}_{#1,\subgroup}}\xspace}
\newcommand{\accscheme}[2]{$(#1\mapsto #2)$-folding scheme\xspace}
\newcommand{\accrel}{\ensuremath{\rel_{\mathpgoth{acc}}}\xspace}
\newcommand{\relpair}{\ensuremath{\mathfrak{p}}\xspace}
\newcommand{\inststar}{\ensuremath{\inst^*}\xspace}
\newcommand{\witstar}{\ensuremath{\wit^*}\xspace}
\newcommand{\relpairstar}{\ensuremath{\relpair^*}\xspace}
\newcommand{\witt}{\ensuremath{\mathrm{w}}\xspace}
\newcommand{\nodelabel}{\ensuremath{\mathfrak{n}}\xspace}
\newcommand{\roundnum}{\ensuremath{\mathpgoth{k}}\xspace}
\newcommand{\manyvar}{\ensuremath{\mathfrak{J}}\xspace}
\newcommand{\nmin}{\ensuremath{[n]_0}\xspace}
\newcommand{\zfin}{\ensuremath{z_{\mathscr{final}}}\xspace}
\newcommand{\relapp}{\ensuremath{\rel_{app}}\xspace}
\newcommand{\relexec}{\ensuremath{\rel_{\mathrm{exec}}}\xspace}
\newcommand{\relF}{\ensuremath{\rel_F}\xspace}
\newcommand{\init}{\ensuremath{\mathsf{init}}\xspace}
\newcommand{\add}{\ensuremath{\mathsf{add}}\xspace}
\newcommand{\del}{\ensuremath{\mathsf{del}}\xspace}
\renewcommand{\read}{\ensuremath{\mathsf{read}}\xspace}
\newcommand{\countrange}{\ensuremath{[M]}\xspace}
\newcommand{\true}{\ensuremath{\mathsf{true}}\xspace}
\newcommand{\false}{\ensuremath{\mathsf{false}}\xspace}
\newcommand{\finstate}{\ensuremath{V}\xspace}
\newcommand{\ops}{\ensuremath{\mathcal{O}}\xspace}
\newcommand{\op}{\ensuremath{\mathscr{op}}\xspace}
\newcommand{\instapp}{\ensuremath{\mathfrak{x}}\xspace}
\newcommand{\witapp}{\ensuremath{\mathfrak{w}}\xspace}
\newcommand{\instnoops}{\ensuremath{\mathbf{x}}\xspace}
 \renewcommand{\path}{\ensuremath{\mathbf{p}}\xspace}
\renewcommand{\root}{\ensuremath{\mathbf{r}}\xspace}
\renewcommand{\eq}{\ensuremath{\mathbf{eq}}\xspace}
\newcommand{\eqpol}[1]{\ensuremath{P_{#1}}\xspace}
\newcommand{\mle}[1]{\ensuremath{\hat{#1}}\xspace}
\newcommand{\predinst}{\ensuremath{\mathpgoth{f}}\xspace}
\renewcommand{\empty}{\ensuremath{g_{\mathscr{empty}}}\xspace}
\newcommand{\funcs}{\ensuremath{\mathsf{F}}\xspace}
\newcommand{\prob}{\ensuremath{\mathsf{prob}}\xspace}
\newcommand{\ztafuncs}{\ensuremath{\mathcal{D}}\xspace}
\newcommand{\prodt}{\ensuremath{\prod_{i=0}^{t-1}}\xspace}
\newcommand{\B}[1]{\ensuremath{\mathbf{B}_{#1}}\xspace}
\newcommand{\shlomomath}[1]{\ensuremath{\text{\usefont{U}{BOONDOX-cal}{m}{n}#1}}\xspace}
\newcommand{\acc}{\ensuremath{\shlomomath{accept}}\xspace}
\newcommand{\mlpcs}{ml-PCS\xspace}
\renewcommand{\zeta}{\mathfrak{z}}
\newcommand{\qzeta}{\ensuremath{q_{\zeta}}\xspace}
\newcommand{\fzeta}{\ensuremath{f_{\zeta}}\xspace}
\newcommand{\prfzeta}{\ensuremath{\prf_{\zeta}}\xspace}
\newcommand{\xinv}{\ensuremath{1/X}\xspace}
\newcommand{\prfother}{\ensuremath{\prf'}\xspace}
\newcommand{\gzeta}{\ensuremath{g_{\zeta}}\xspace}
\newcommand{\dzeta}{\ensuremath{D_{\zeta}}\xspace}
\newcommand{\szeta}{\ensuremath{s_{\zeta}}\xspace}
\newcommand{\hzeta}{\ensuremath{h_{\zeta}}\xspace}
\newcommand{\ginv}{\ensuremath{\bar{g}_{\zeta}}\xspace}
\newcommand{\hinv}{\ensuremath{\bar{h}_{\zeta}}\xspace}
\newcommand{\sinv}{\ensuremath{\bar{s}_{\zeta}}\xspace}
\newcommand{\halpha}{\ensuremath{h_{\alpha}}\xspace}
% \newcommand{\instF}{\ensuremath{\mathrm{x}}\xspace}
% \newcommand{\witF}{\ensuremath{\mathrm{w}}\xspace}
\newcommand{\groupgen}{\ensuremath{\shlomomath{g}}\xspace}
\begin{document}
    \maketitle
\begin{abstract}
We construct a pairing-based polynomial commitment scheme for multilinear polynomials  of size $n$ where
constructing an opening proof requires  $O(n)$ field operations, and $2n+O(\sqrt n)$ scalar multiplications. Moreover,
the opening proof consists of a constant number of field elements.
This is a significant improvement over previous works which would require either
\begin{enumerate}
 \item $O(n\log n)$ field operations; or
 \item $O(\log n)$ size opening proof.
\end{enumerate}
The main technical component is a new method of verifiably folding a witness via univariate polynomial division.
As opposed to previous methods, the proof size and prover time remain constant \emph{regardless of the folding factor}.
% a As opposed to more familiar folding methods - e.g. as used in the sumcheck protocol - this allows to fold the witness by a \emph{super-constant} factor with a \emph{linear} (rather than superlinear)  number of field operations and scalar multiplications.
\end{abstract}
\section{Introduction}
    Polynomial Commitment Schemes (PCSs)\cite{kzg} allow a party to commit to a polynomial and later prove an evaluation of the polynomial is correct.
    That is, for a commitment $\cm$ and values $a,b$; a prover  \prv can produce a proof that $\cm = \com(f(X))$ and $f(a) = b$.
    PCSs form an essential part of most modern Succinct Non-interactive ARguments of Knowledge (SNARKs). They allow a protocol designer to focus on designing a so-called  polynomial Interactive Oracle Proof  which can then be compiled, via a PCS, to a SNARK (see \cite{dark,plonk,marlin} for descriptions of such compilers).
    In fact, many of the most important properties of a SNARK, like proof size, verifier complexity, and cryptographic assumptions, follow primarily from the PCS.
    The earliest polynomial commitment schemes \cite{kzg} supported univariate polynomials and were used to construct SNARKs like Plonk \cite{plonk} and Marlin \cite{marlin} with $O(n \log n)$ prover complexity and constant proof size.
    A different class of SNARKs \cite{spartan, hyperplonk} arising from the sumcheck protocol \cite{lfkn} have linear prover time, but require \emph{multilinear} Polynomial Commitment Schemes (\mlpcs's).
    
\subsection{Our results}
    Existing transformations from a univariate PCS to \mlpcs are either linear time but require a logarithmic opening proof size, like \gemini\cite{gemini} and \zeromorph\cite{zeromorph}, or have constant size opening proofs but incur an additional $O(n \log n)$ prover cost to perform univariate polynomial multiplication via FFT's.
    We propose a new protocol that goes beyond this tradeoff: \mercury has constant proof size and only $O(n)$ prover operations (in addition to the $O(\lambda n/(\log(\lambda n))$ operations for muti-scalar multiplications arising in KZG commitments).
    It is also concretely more efficient than existing schemes with similar verifier complexity\footnote{The \mlpcs from \cite{kzh} requires only $O(\sqrt{n})$ scalar multiplications. However, it requires $O(\log n)$ proof length and $O(\log n)$ verifier pairings whereas all schemes in table $1$ require only two.}in terms of the required scalar multiplications, as can be seen in table $1$. 



\begin{table}[!htbp]\label{table:comparison}
	\caption{ Comparison of pairing-based \mlpcs. \G denotes a scalar multiplication. All verifiers below additionally require two pairings. Proof size is measured in elements of \F, and uses the fact that a \G-element is encoded by two \F-elements.}
	\centering
% \begin{adjustbox}{width=1\textwidth}
	\begin{tabular}{l|l|l|l}
	\thead{Scheme} & \thead{Proof size} & \thead{Prover Work} & \thead{Verifier Work}  \\ \hline
		univariate-based e.g.\cite{logupgkr}
		        & $O(1)$ &        $O(n\log n)$ \F,$O(n)$ \G  & $O(\log n)$ \F,   $O(1)$ \G   \\ \hline
		\gemini\cite{gemini} & $O(\log n)$ &  $O(n)$ \F, $3n$ \G     &    $O(\log n)$ \F, $O(\log n)$ \G \\ \hline
		
		\zeromorph\cite{zeromorph} & $O(\log n)$ & $O(n)$ \F, $2.5n$ \G   &  $O(\log n)$ \F, $O(\log n)$ \G         \\ \hline
		\mercury (this work)       & $O(1)$ & $O(n)$ \F, $2n+ O(\sqrt n)$ \G     & $O(\log n)$ \F, $O(1)$ \G          \\ \hline
	\end{tabular}
% \end{adjustbox}
\label{table:prover-work}
\end{table} 

\section{Overview of technique}
% \begin{remark}
 \textit{In this overview, we use some of the notation defined in Sections \ref{sec:terminology} and \ref{sec:multilin-polys}.} \\ 
% \end{remark}

Our technique is best thought of as an improvement of the \gemini \mlpcs\cite{gemini}.
Let's start by recalling how \gemini works.
\gemini commits to a multilinear function as a \emph{univariate} KZG commitment\cite{kzg}. Specifically,
fix a vector $f\in \F^n$ describing the function's values on the boolean cube \B{s} where $s=\log n$. That is, we think of $f$ as representing the 
multilinear
\[M(X_0,\ldots,X_{s-1})= \sumi{n}\eq(i,X_0,\ldots,X_{s-1}) f_i.\]
(Here, as explained in Section \ref{sec:multilin-polys}, we interpret $i$ as its binary decomposition $(i_0,\ldots,i_{s-1})$
when used as input to \eq.)
Let $\srs =\sett{\enc{x^i}}{i<n}$be a KZG structured reference string.
 \gemini outputs $\cm=\enc{f(x)}=\sumi{n}f_i \enc{x^i}$ as a commitment to $M$.  


Now suppose prover \prv wants to convince verifier \ver  that $M(z)=v$, for some $z=(z_0,\ldots,z_{s-1})\in \F^s$. In \gemini, \prv sends commitments $\cm_1,\ldots,\cm_s$ to the $s$ incremental restrictions leading  to evaluation at $z$.
Namely, to $M_1=M(z_0,X_1,\ldots,X_{s-1})$, $M_2=M(z_0,z_1,X_2,\ldots,X_{s-1}),\ldots,M_s=M(z_0,\ldots,z_{s-1})$.
Assuming \prv sent commitments to the correct functions, all that is needed is to check that $\cm_s$ is the commitment to the constant $v$. Of course, the interesting part is proving the commitments \emph{are} to the correct functions!

For this purpose, \gemini exploits a connection between $M$ and its corresponding univariate $f(X)$:
Write $f(X)=f_0(X^2)+X f_1(X^2)$, for $f_0(X),f_1(X)$ of degree $<n/2$. Let $f_{z_0}(X)$ be the univariate corresponding to $M_1$ defined above. Then, we have
\[f_{z_0}(X)=(1-z_0)f_0(X)+ z_0 f_1(X).\]
Additionally, we can evaluate $f_0$ and $f_1$ via $f$  using the equations
\[f_0(X^2)=\frac{f(X)+f(-X)}{2}, f_1(X^2)=\frac{f(X)-f(-X)}{2X}\]
Thus, we can perform consistency checks between each pair $\cm_{i-1},\cm_i$, via univariate KZG openings at a random challenge, inductively showing $\cm_i$ is indeed the commitment to the next desired restriction.
Of course, we get $O(s)=O(\log n)$ proof length due to this sequence of restriction commitments.

Here is a first idea on how to reduce proof length.
Protocols based on univariate polynomials allow us to do multilinear evaluation in $O(n\log n)$ prover time with constant proof size (e.g. Section 5 of \cite{logupgkr}).
Choose a parameter $t$ and set $b=2^t$.
We can run \emph{only the first $t$ rounds} of \gemini, reaching a restricted multilinear on $n-t$ variables.
If $n'=n/b\leq n/\log n$, we can afford to run a univariate protocol with $O(n' \log n')=O(n)$ prover time to evaluate $M_t(z_t,\ldots,z_{s-1})$.
This still doesn't take us to overall constant proof size - as we  need to use a super-constant $t$ to reach such $n'$. (For us $t=\log n/2$ will be optimal, although $t\geq \log \log n$ suffices here.)


% Here comes the second idea.
This raises the question - can we ``skip'' the intermediate \gemini rounds and send \emph{only} the commitment $\cm_t$, and directly prove it is consistent with the original \cm?
Extrapolating the \gemini strategy in the natural way, we get the answer - yes, but not with constant proof size:
We can decompose $f$ into $b$ polynomials of degree $<n/b$: $f(X)=\sum_{0\leq i <b} X^i f_i(X^b)$.
As in the $b=2$ case, one can show the univariate $f'(X)$ corresponding to $M_t$ is a linear combination
of the \set{f_i(X)}. Moreover, evaluating the $f_i$ using $f$ (for the consistency check) can be done.
However, it requires $b$ evaluations of $f$. Specifically,
$f_i(r^b)$ is a linear combination of  $\set{f(r),f(r\omega),\ldots,f(r\omega^{b-1})}$ where $\omega$ is a primitive $b$'th root of unity.


Our central innovation is a different way to prove $\cm_t$ is correct \emph{with} constant proof size.
Let's switch notation and denote the opening point as $u=(u_1,u_2)$ where $u_1\in \F^t,u_2\in \F^{s-t}$.
The (univariate corresponding to the) correct restricted polynomial is 
\[h(X) = \sum_{0\leq i < b} \eq(i,u_1)f_i(X).\]
% We'll show $\cm_t$ opens to $h(\alpha)$ for random $\alpha$ chosen by \ver as follows.
Let $g(X)\defeq f(X) \mod X^b-\alpha$.
Calculation shows
\[g(X)= \sum_{0\leq i < b} X^i f_i(\alpha).\]
% \prv will send $\g\defeq \cm(g)$ and prove its correctness via a quotient.
The multilinear $\mle{g}$ corresponding to $g(X)$ is 
\[\mle{g}(X_0,\ldots X_{t-1}) = \sum_{0\leq i < b} \eq(i,X_0,\ldots,X_{t-1})f_i(\alpha).
\]
In particular, we have 
\[\mle{g}(u_1) = \sum_{0\leq i < b} \eq(i,u_1)f_i(\alpha)=h(\alpha).\]
In words, the evaluation of $g$ at $u_1$ as a \emph{multilinear} corresponds to 
the evaluation of $h$ at $\alpha$ as a univariate!
We can use standard univariate KZG to open $\cm_t$ at $\alpha$.
And, crucially, we can afford to evaluate $\mle{g}(u_1)$ using the aforementioned univariate protocols as it is of size $b$ rather than $n$.
In summary, we can show a committed polynomial corresponds to the correct restriction. And now, again, we can afford to open $h$ as a multilinear at $u_2$ using univariate protocols
as it has size $n/b$ rather than $n$.
\paragraph{Comparison to sumcheck}
It is instructive to see what  happens if we try to get a similar result via a modification of the sumcheck protocol \cite{lfkn}.
Note first that a multilinear evaluation can indeed   be written as a sum over the function's values on \B{s} multiplied by the \eq function:
$$ M(u) = \sum_{b \in \B{s}} \eq(b, u) M(b). $$


The classic sumcheck protocol, like \gemini, works by $\log n$ reductions of the domain size by a factor of two; each round fixing one more variable of the summed function. In the above spirit, we could look at a modified sumcheck protocol, where the first variable ranges over a domain of super-constant size $b$. The first round univariate $P_1$ would thus have degree roughly $2b$. 
To maintain constant proof length, we could send a commitment to $P_1$ rather than its coefficients (as usually done in sumcheck).
However, \emph{computing} $P_1$ would require superlinear time  $O(n \log b)$ - as we need to perform a $b$-size FFT for $n/b$ values of the second variable appearing in the sum. 


\section{Preliminaries}
\subsection{Terminology and conventions}\label{sec:terminology}
\paragraph{Fields and Groups}
We assume our field \F is of prime order.
We denote by \polysofdeg{d} the set of univariate polynomials over \F of degree smaller than d. 
We assume all algorithms described receive as an implicit parameter the security parameter $\lambda$.

Whenever we use the term \emph{efficient}, we mean an algorithm running in time \poly. Furthermore,
we assume an \emph{object generator} \obgen that is run with input $\lambda$ before all protocols, and returns all fields and groups used. Specifically, in our protocol $\obgen(\lambda) = (\F, \G, \Gtwo, \Gt, e, \groupgen, \groupgen_2,\groupgen_t)$ where
\begin{itemize}
\item \F is a prime field of super-polynomial size $r = \lambda^{\omega(1)}$
.
\item $\G,\Gtwo,\Gt$ are all groups of size $r$, and $e$ is an efficiently computable non-degenerate pairing
$e : \G \times \Gtwo \to \Gt$.
\item $\groupgen,\groupgen_2$ are uniformly chosen generators such that $e(\groupgen, \groupgen_2) = \groupgen_t$.
\end{itemize}
We usually let the $\lambda$ parameter be implicit, i.e.\ write \F instead of $\F(\lambda)$.
We write \G and \Gtwo additively. We use the notations $\enc{x}\defeq x\cdot \groupgen$ and $\enctwo{x}\defeq x\cdot \groupgen_2$.

\paragraph{Vectors and polynomials}
We work with integer parameter $n$ that we'll assume throughout the paper  is of the form
$n=2^{2t}$ for integer $t>0$. We'll denote its square root by $b\defeq 2^t=\sqrt{n}$.
We index vectors starting from zero. For example, for $g\in \F^b$ we have $g=(g_0,\ldots,g_{b-1})$.
We associate vectors with univariate polynomials in the following natural way:
Given $g\in \F^b$ we denote $g(X)\defeq \sum_{0\leq i < b} g_i X^i$.

We make the convention that integer ranges in sums begin at zero if not specified otherwise. Thus, we write
$g(X)=\sumi{b}g_i X^i$.

We assume vectors of size $n$ are indexed by two indices ranging over $\set{0,\ldots,b-1}$. Thus, for $f\in \F^n$, we have $f=(f_{0,0},\ldots,f_{0,b-1},\ldots,f_{b-1,0},\ldots,f_{b-1,b-1})$.
 For $0\leq i <b$, we denote by $f_i$ the vector $(f_{0,i},\ldots, f_{b-1,i})$.

In particular, for $f\in \F^n$ we have under these notations that
\[f(X)\defeq \sumi{b}X^i f_i(X^b) = \sumi{b}\sumj{b}f_{i,j}X^{i+j\cdot b}\]
 
For integet $m>0$, we denote by \B{m} the binary cube $\set{0,1}^m\subset \F^m$ of dimension $m$.
\subsection{Multilinear polynomials}\label{sec:multilin-polys}
Let $n=2^{2t}$, and $s=2t$.
We define the well-known \eq multilinear polynomial in $2s$ variables. 
\[\eq(x,y) \defeq \prod_{i=0}^{s-1} ( x_i y_i + (1-x_i)(1-y_i))\]
We have for $x,y \in \B{s}$, $\eq(x,y)=1$ when $x=y$ and $\eq(x,y)=0$ otherwise.

We use the convention that an integer $0\leq i < n$ can be used as an input to \eq by interpreting $i$ as its binary representation.
Namely, for $0\leq i <n$, $u\in \F^s$, $\eq(i,u)\defeq \eq(i_0,\ldots, i_{s-1},u)$ where $i=\sumj{s} i_j 2^{j}$.

For $f\in \F^n$, we define $\mle{f}$ to be the multilinear polynomial obtaining $f$'s values on the boolean cube.
Namely,
\[\mle{f}(X_0,\ldots,X_{s-1}) \defeq \sumi{n}\eq(i,X_0,\ldots,X_{s-1})\cdot f_i.\]

\paragraph{Decomposing \eq}
We'll overload \eq to also denote the analogous equality function for $x,y \in \B{t}$.
With this overloading, given $w_1,w_2,u_1,u_2\in \B{t}$ we have the convenient decomposition
\[ \eq( (w_1,w_2),(u_1,u_2)) = \eq(w_1,u_1)\eq(w_2,u_2).\]


\subsection{The algebraic group model}\label{subsec:agm}
We introduce some terminology from \cite{plonk} to capture analysis in the Algebraic Group Model of Fuchsbauer, Kiltz and Loss\cite{AGM}.
In this subsection, we use the notation $\G_1=\G$.
In our protocols, by an \emph{algebraic adversary} \adv in an SRS-based protocol we mean a \poly-time algorithm which satisfies the following.
\begin{itemize}
 \item For $i\in \set{1,2}$, whenever \adv outputs an element $A\in \Gi$, it also outputs a vector $v$ over \F such that $A = <v,\srsi>$.
\end{itemize}

First we say our \srs \emph{has degree $Q$} if all elements of \srsi are of the form  \enci{f(x)} for $f\in \polysofdeg{Q+1}$ and uniform $x\in \F$. In the following discussion let us assume we are executing a protocol with a degree $Q$ SRS, and denote by $f_{i,j}$ the corresponding polynomial for the $j$'th element of \srsi.

Denote by $a,b$ the vectors of $\F$-elements whose encodings in $\G_1,\G_2$ an algebraic adversary \adv outputs during a protocol execution; e.g., the $j$'th $\G_1$ element output by \adv is \enc{a_j}.

By a ``real pairing check'' we mean a check of the form
\[(a\cdot T_1) \cdot (T_2\cdot b)=0\]
for some matrices $T_1,T_2$ over $\F$.
Note that such a check can indeed be done efficiently given the encoded elements and the pairing function $e:\G_1\times \G_2\to \Gt$.



Given such a ``real pairing check'', and the adversary \adv and protocol execution during which the elements were output, define the corresponding ``ideal check'' as follows.
Since \adv is algebraic when he outputs \enci{a_j} he also outputs a vector $v$ such that, from linearity, $a_j = \sum v_\ell f_{i,\ell}(x)=R_{i,j}(x)$ for $R_{i,j}(X) \defeq \sum v_\ell f_{i,\ell}(X)$.
Denote, for $i\in \set{1,2}$ the vector of polynomials $R_i=(R_{i,j})_j$.
The corresponding ideal check, checks as a polynomial identity whether
\[(R_1 \cdot T_1)\cdot (T_2\cdot R_2) \equiv 0\]


The following lemma is inspired by \cite{AGM}'s analysis of \cite{Groth16},
and tells us that for soundness analysis against algebraic adversaries it suffices to look at ideal checks.
Before stating the lemma we define the $Q$-DLOG assumption similarly to \cite{AGM}.
\begin{dfn}\label{ref:qdlog}
 Fix integer $Q$. The \emph{$Q$-DLOG assumption for $(\G_1,\G_2)$} states that given 
 \[\enc{1},\enc{x},\ldots,\enc{x^Q},\enctwo{1},\enctwo{x},\ldots,\enctwo{x^Q}\]
 for uniformly chosen $x\in \F$, the probability of an efficient \adv outputting $x$
 is \negl.
\end{dfn}



\begin{lemma}\label{lem:AGManalysis}
Assume the $Q$-DLOG for $(\G_1,\G_2)$.
 Given an algebraic adversary \adv participating in a protocol with a degree $Q$ SRS,
 the probability of any real pairing check passing is larger by at most an additive \negl factor than the probability the corresponding ideal check holds.
\end{lemma}
See \cite{plonk} for the proof.






\subsection{Polynomial commitment schemes for multilinear polynomials}

We give a formal definition of an \mlpcs secure in the algebraic group model.
\begin{dfn}\label{dfn:mlpcs}
Let $n=2^s$.  A multilinear polynomial commitment scheme (ml-PCS) consists of 
\begin{itemize}
 \item $\gen(n)$ -  a randomized algorithm that outputs an SRS \srs.
 \item $\com(f,\srs)$ - that given a polynomial $f\in \F^n$ returns a commitment \cm to $f$.
 \item A public coin protocol  $\open(\cm,n,u,v)$ between parties \prv and \ver. \prv is given $ f\in \F^n$. \prv and \ver are both given integer $n$, \cm - the purported commitment to $f$, $u\in \F^s$ and $v\in \F$ - the purported value $\mle{f}(u)$.
\end{itemize}
such that
\begin{itemize}
 \item \textbf{Completeness:} 
 Suppose that $\cm = \com(f,\srs)$.  Then if \open is run correctly with values
 $n, \cm,u,v=\mle{f}(u)$, \ver outputs \acc with probability one.
 \item \textbf{Knowledge soundness in the algebraic group model:} There exists an efficient \ext such that for any efficient algebraic adversary \adv the probability of \adv winning the following game is \negl over the randomness of \adv and \gen.
 \begin{enumerate}
  \item Given \srs, \adv outputs $n,\cm$.
  \item \ext, given access to the messages of \adv during the previous step, outputs $f\in \F^n$.
  \item \adv outputs $ u\in \F^s$ and  $v \in \F$.
  \item \adv takes the part of \prv in the protocol \open with inputs
  $n,\cm,u,v$.
  \item $\adv$ wins if 
  \begin{itemize} 
   \item \ver outputs \acc at the end of the protocol.
   \item $\mle{f}(u)\neq v$.
  \end{itemize}

 \end{enumerate}

\end{itemize}
\end{dfn}

\section{Components}\label{sec:components}
In this section we go over known components (with some new optimizations), that will be used in our main protocol in Section \ref{sec:main}. The treatment will  be  semi-formal, and assume basic familiarity with the KZG polynomial commitment scheme \cite{kzg}. The formal treatment will be part of the description and knowledge soundness proof of the main protocol in Section \ref{sec:main}.
\subsection{Inner products in $O(b\log b)$ time.}
Fix polynomials $g_1(X)=\sum_{i=0}^{d_1} a_i X^i,g_2=\sum_{i=0}^{d_2} b_i X^i$ in $\polys$.
We define $<g_1,g_2>$ to be $\sum_{i=0}^d a_i b_i$ where $d\defeq \min \set{d_1,d_2}$. 
We present a convenient way to verify inner products $<g_1,g_2>$ similar to \cite{bootle,sonic}.
The basic observation is that  $<g_1,g_2>$ is the constant coefficient of the rational function
$R(X)\defeq g_1(X) g_2(1/X)$.
Thus, $<g_1,g_2>=v$ is equivalent to the existence of polynomials $S_1(X),S_2(X)$ such that
\[g_1(X) g_2(1/X)=1/X\cdot S_1(1/X) + v + X\cdot S_2(X).\] 
We can thus sends commitments to $S_1,S_2$ as proof of the correctness of $v$.
As an optimization, we observe that we can ``symmetrize'' $R$ and look instead at the rational function

\[R'(X)\defeq g_1(X) g_2(1/X)+g_1(1/X) g_2(X).\]
The advantage of $R'$ is that the negative and positive coefficients are equal. Thus,
$<g_1,g_2>=v$ is equivalent to the existence of $S(X)\in \polys$ such that

\[ g_1(X) g_2(1/X)+g_1(1/X) g_2(X)=2v + X\cdot S(X) + (1/X)S(1/X).\]

\begin{claim}\label{clm:computeS}
 Suppose $g_1(X),g_2(X)\in \polysofdeg{b}$. Let $S(X)$ be as defined above.
 Then $S$ can be computed in $O(b \log b)$ \F-operations.
\end{claim}
\begin{proof}
When $g_1(X),g_2(X)\in \polysofdeg{b}$ we multiply the equation above by $X^{b-1}$ to get
\[ X^{b-1}(g_1(X) g_2(1/X)+g_1(1/X) g_2(X))=X^{b-1}(2v + X\cdot S(X) + (1/X)S(1/X)).\]
We can use an $O(b \log b )$ time FFT to evaluate the LHS on $2b$ points. We then do an inverse
FFT to get the coefficients $c_0,\ldots,c_{2b-2}$ of the LHS. Now, we can output $S=(c_b,\ldots, c_{2b-2})$.
\end{proof}

\paragraph{Batching inner product checks}

Suppose we now have two  inner product claims  $<g_1,g_2>=v_1$ and $<h_1,h_2>=v_2$. 
The following claim gives us a way to randomly batch them so that one polynomial $S(X)$ suffices to prove both.
% \begin{enumerate}
%  \item 
% \ver  chooses random $\gamma \in \F$
% \item \prv sends $S\in \polys$ such that 
\begin{claim}\label{claim:batchipa}
 Fix polynomials $g_1,g_2,h_1,h_2\in \polys$ and $v_1,v_2\in \F$.
 Suppose $<g_1,g_2>\neq v_1$ or $<h_1,h_2>\neq v_2$. Then, e.w.p $1/|\F|$ over $\gamma\in \F$
 there does not exist $S(X)\in\polys$ such that
\[ g_1(X)g_2(\xinv)+ g_1(\xinv) g_2(X) + \gamma(h_1(X)h_2(\xinv) + h_1(\xinv)h_2(X)) \]
\[= 2(v_1+\gamma v_2) + X\cdot S(X)+(\xinv)S(\xinv)\]
 
\end{claim}
\begin{proof}
Denote $(v'_1,v'_2)=(<g_1,g_2>,<h_1,h_2>))$.
 The constant coefficient of the LHS is $v'_1+\gamma v'_2$.
To satisfy the equation in the claim for some $S$, we need
 \[v'_1+\gamma v'_2=v_1+\gamma v_2,\]
which can hold for at most one $\gamma$ when $(v_1,v_2)\neq (v'_1,v'_2)$.
\end{proof}

\subsection{Multilinear evaluations as inner products of univariate polynomials.}
For $u\in \B{t}$ define the polynomial $\eqpol{u} (X)\defeq  \sumi{b}\eq(i,u)X^i$. 
Note that for $g(X)\in \polysofdeg{b}$, we have
\[<\eqpol{u},g>=\sumi{b}\eq(i,u) g_i = \mle{g}(u).\]

\noindent
As leveraged in \cite{halo}, we have the product formula
\[\eqpol{u}(X)=\prodt\left(u_i X^{2^i}+1-u_i\right),
\]
implying $\eqpol{u}(X)$ can be evaluated in $O(t)$ \F-operations. Hence, a verifier \ver operating in $O(\log n)$ time can evaluate $\eqpol{u}(X)$ itself.

Using the polynomials \eqpol{u}, mutlilinear evaluations can be proven in a batched manner based on Claim \ref{claim:batchipa}:
Suppose we want to show given committed univariates $g(X),h(X)  \in\polys$, $u_1,u_2\in \F^t,v_1,v_2\in \F$ that
$\mle{g}(u_1)=v_1$ and $\mle{h}(u_2)=v_2$.
\begin{enumerate}
 \item \ver sends random $\gamma\in \F$.
 \item\label{item:eqsec4} \prv sends commitment to $S$ such that
\[ g(X)P_{u_1}(1/X)+ g(1/X) P_{u_1}(X) + \gamma(h(X)P_{u_2}(1/X) + h(1/X)P_{u_2}(X))\]
\[= 2(v_1+\gamma v_2) + X\cdot S(X)+(1/X)S(1/X).\]
\item \ver chooses a random $\zeta\in \F$.
\item \prv sends and proves correctness of the values of $g,h$ and $S$ on $\zeta,1/\zeta$. 
\item \ver evaluates $P_{u_1},P_{u_2}$ at $\zeta,1/\zeta$. 
\item \ver checks the equation in step \ref{item:eqsec4} holds at $\zeta$.
\end{enumerate}

\subsection{Degree checks}
The idea presented here is from \cite{thakur}.
Suppose \prv wants to prove to \ver that \cm is a commitment to a polynomial $g(X)\in \polysofdeg{b}$.
Let $D(X)\defeq  X^{b-1} g(1/X)$. The idea is that $D(X)$ is a polynomial if and only if $g(X)$ has degree $<b$.
Thus, assuming our structured reference string  doesn't contain negative powers, \prv can commit to $D$ if
and only if $g(X)\in \polysofdeg{b}$.

This motivates the following protocol.
\begin{enumerate}
 \item 
\prv sends a commitment \d to $D(X)$.
\item \ver chooses random $\zeta \in \F$.
\item \prv sends $\dzeta \defeq D(\zeta), \ginv \defeq  g(1/\zeta)$, and uses KZG to prove their correctness.
\item \ver can now check $D$'s correctness on   $\zeta$, using the equation
\[\dzeta \stackrel{?}{=}\zeta^{b-1} \ginv.\]

\end{enumerate}

\section{Univariate division}

Our protocol crucially relies on the following simple claim about division by a polynomial of the form
$X^b-\alpha$.
\begin{claim}\label{clm:univariatemod}
 Fix integers $b>0$ and let $n=b^2$. Fix $\alpha\in \F$, and $f(X)\in \polysofdeg{n}$.
Let $f_0(X),\ldots,f_{b-1}(X)\in \polysofdeg{b}$ be such that
$f(X)=\sumi{b}X^i f_i(X^b)$.
 Let $g(X)\in \polysofdeg{b},q(X)\in \polys$ be such that 
 \[f(X)=(X^b-\alpha)\cdot q(X) + g(X).\]
 Then,
 \begin{enumerate}
  \item $g(X)=\sumi{b} X^i f_i(\alpha)$.
  \item The coefficients of $q(X)$ can be computed in $O(n)$ \F-operations.
 \end{enumerate}

\end{claim}
\begin{proof}
To see the first item, note that reduction $\mod X^b-\alpha$ corresponds to substituting $\alpha$ into $X^b$ inside each $f_i(X^b)$ in the expression $\sumi{b}X^i f_i(X^b)$.
We proceed to the computation of $q(X)$.
 We compute for each $0\leq i <b$, the coefficients of the quotient $q_i(X)\in \polys$ such that
\[f_i(X)=q_i(X)(X-\alpha)+ f_i(\alpha).\]
 Using Horner's method for division by the linear polynomial $X-\alpha$ this requires only $n$ multiplications and additions in \F.
Now, we have that
\[f(X)=\sumi{b}X^i f_i(X^b) = \sumi{b} X^i \left(q_i(X^b)(X^b-\alpha)+f_i(\alpha)\right)= q(X)(X^b-\alpha) + g(X),\]
for $q(X)\defeq \sumi{b}X^i q_i(X^b)$.
Thus, the coefficients of $q(X)$ are simply the interleaving of the coefficients of the \set{q_i(X)}.
\end{proof}


\section{Main Construction}\label{sec:main}
\mercury is the tuple $(\gen,\com,\open)$ described next. \\    

\noindent
\underline{$\gen(n)$:}
Choose random $x\in \F$ and outputs \set{\enc{1},\enc{x},\ldots,\enc{x^{n-1}},\enctwo{1},\enctwo{x}}\\

\noindent
\underline{$\com(n,f,\srs)$:}
 Output $\sumi{b}\sumj{b}f_{i,j}\cdot \enc{x^{i\cdot b + j}}$.\\ \\ 

\noindent
\underline{$\open(n,\cm,u,v;f)$:} \\ \noindent
\begin{enumerate}
 \item \textsf{Committing to partial sums:} \ 
\begin{enumerate}
\item Let $u=(u_1,u_2)$ for $u_1,u_2 \in \B{t}$. \prv computes the polynomial $h(X)\defeq \sumi{b}\eq(i,u_1) f_i(X)$. Note that the coefficient of $X^j$ in $h(X)$ is $\sumi{b}\eq(i,u_1) f_{i,j}$ - hence we think of it as a commitment to partial sums. 
 \item \prv computes and sends $\h\defeq\enc{h(x)}$.
 
 \end{enumerate}
\item \textsf{ Committing to  ``folded'' polynomial $g$:} 
\begin{enumerate}
 \item \ver sends random $\alpha \in \F$.
\item \prv computes polynomials $g(X) \in \polysofdeg{b}$ and $q(X)\in \polys$ such that
\[f(X)=(X^b-\alpha)\cdot q(X) + g(X).\]\label{step:modalpha}
\item \prv computes and sends $\q\defeq \enc{q(x)}$ and $\g\defeq \enc{g(x)}$.

\end{enumerate}

\item  \textsf{Sending proofs of correctness for $h$ and the degree of $g$:} 
\begin{enumerate}
\item \ver sends a random batching challenge $\gamma \in \F$.
\item \label{step:sendS} \prv computes and sends $\s=\enc{S(x)}$ where $S(X)\in \F[X]$ is  such that
\[g(X)\eqpol{u_1}(1/X) + g(1/X)\eqpol{u_1}(X)+ \gamma\cdot ( h(X)\eqpol{u_2}(1/X) + h(1/X)\eqpol{u_2}(X) )\]
\[  =2(h(\alpha) +\gamma \cdot v)+X\cdot S(X)+(1/X)S(1/X).\]
\item \prv computes and sends $\d\defeq \enc{D(x)}$ where  \label{step:sendD}
\[D(X)\defeq X^{b-1} g(1/X).\]
\end{enumerate}
\item  \textsf{KZG evaluations:} 
\begin{enumerate}
\item  \ver sends a random evaluation challenge $\zeta \in \F$.
\item \prv sends the values $ \gzeta \defeq g(\zeta), \ginv \defeq g(1/\zeta), \hzeta \defeq h(\zeta), \hinv \defeq h(1/\zeta), \halpha\defeq h(\alpha),\szeta \defeq S(\zeta),\sinv\defeq S(1/\zeta)$.\label{step:evals}
\item\label{step:computevals} \ver computes the expected values for $D(\zeta)$ and $h(\alpha)$ assuming the equations in steps \ref{step:sendS},\ref{step:sendD} are satisfied. That is,  $\dzeta\defeq  \zeta^{b-1} \ginv$, and 
\[\halpha\defeq \left(\gzeta \eqpol{u_1}(1/\zeta) + \ginv \eqpol{u_1}(\zeta) + \gamma(\hzeta \eqpol{u_2}(1/\zeta) + \hinv \eqpol{u_2}(\zeta)-2v) - \zeta \szeta - (1/\zeta)\sinv\right)/2.\]
% \item \ver sends a random KZG batching challenge $\eta\in \F$.
\item \prv computes and sends the KZG opening proof  \prfzeta to check the equation of step \ref{step:modalpha} at $\zeta$. That is $\prfzeta \defeq \enc{H(x)}$ for
\[H(X) \defeq \frac{f(X)-(\zeta^b-\alpha)q(X)-\gzeta}{X-\zeta}.\]
\item \prv computes and sends a batched KZG opening proof \prfother for the values  sent in step \ref{step:evals} and computed by \ver in step \ref{step:computevals}, as described in Section 4 of \cite{shplonk}.
\item \ver checks the proof \prfzeta via pairings as in \cite{kzg}:\label{step:checkfirst}
   \[e(\cm-\enc{\zeta^b-\alpha}\cdot \q -\gzeta,\enctwo{1})=e(\prfzeta,\enctwo{x-\zeta}).\]
   \item \ver checks the opening proof \prfother as described in \cite{shplonk}. \label{step:checklast} 
%    \item \ver checks the equation
% 
% \[\gzeta \eqpol{u_1}(1/\zeta) + \ginv \eqpol{u_1}(\zeta) + \gamma(\hzeta \eqpol{u_2}(1/\zeta) + \hinv \eqpol{u_2}(\zeta))= \halpha +\gamma v + \zeta \szeta + (1/\zeta)\sinv.\]  
% \item \ver checks the equation $\dzeta=\zeta^{b-1} \ginv$.
\item If one of the checks in steps \ref{step:checkfirst},\ref{step:checklast} fails, \ver outputs \rej. Otherwise \ver outputs \acc.

\end{enumerate}
\end{enumerate}

\paragraph{Runtime of \prv:}
Computing $q(X)$ in step \ref{step:modalpha} requires $O(n)$ operations by Claim \ref{clm:univariatemod}.
Computing $\q$ and $\prfzeta$ requires two MSMs of size $n$. All other steps are on polynomials of size $O(b)=O(\sqrt{n})$.
Thus, other commitments clearly require $O(\sqrt{n})$ scalar multiplications. It is easy to see other steps require $o(n)$ \F-operations. The least trivial of these is perhaps the computation of $S(X)$ shown to require $O(b \log b)=o(n)$ operations in Claim \ref{clm:computeS}.
\paragraph{Proving knowledge soundness:}

Let \adv be an efficient algebraic adversary participating in the Knowledge Soundness game from
Definition \ref{dfn:mlpcs}.
We show its probability of winning the game is \negl.
We define the extractor \ext to simply output the vector $f\in \F^n$ \adv outputs (as it's algebraic) with $\com(f)=\cm$ together with \cm.

% Let $f\in \F^n$ be the vector sent by \adv in the third step of the game
% such that $\cm=\enc{f(x)}$.
As \adv is algebraic, when sending the commitments \h,\q,\g,\s,\d,\prfzeta,\prfother during protocol execution it also sends polynomials $h(X),q(X),g(X),$ $S(X),D(X),H(X),Q(X)\in \polysofdeg{n}$ such that the former are their corresponding commitments.
Let $E$ be the event that \ver outputs \acc.
Let $A$ be the event that \adv wins the knowledge soundness game.
Note that by definition $A\subset E$, and our goal is to show $\prob(A)=\negl$.
We will define a constant number of events such that their union contains $A$  and each has probability \negl.
This implies the knowledge soundness of the protocol.

$E$ implies all pairing checks have passed.
Let $E_0\subset E$ be the event that one of the corresponding ideal pairing checks as defined in Section \ref{subsec:agm} didn't pass.
According to Lemma \ref{lem:AGManalysis}, $\prob(E_0)=\negl$.

Given that $E_0$ didn't occur, we have from the knowledge soundness proof of batched KZG in  Section 3 of \cite{shplonk}  that the evaluations sent by \prv and computed by \ver are all correct. That is,
\begin{enumerate}
 \item 
$ \gzeta=g(\zeta),\ginv = g(1/\zeta),\hzeta= h(\zeta),\hinv =h(1/\zeta), \szeta=S(\zeta),\sinv = S(1/\zeta)$,
\item\label{item:first}
$ D(\zeta) = \zeta^{b-1} g(1/\zeta)$,
\item 
\[2(h(\alpha)+\gamma v) =  g(\zeta) \eqpol{u_1}(1/\zeta) + g(1/\zeta)\eqpol{u_1}(\zeta) + \gamma(h(\zeta) \eqpol{u_2}(1/\zeta) + h(1/\zeta) \eqpol{u_2}(\zeta)) - \zeta S(\zeta) - (1/\zeta)S(1/\zeta).\]
\item\label{item:last}$g(\zeta) =  f(\zeta)-(\zeta^b-\alpha)q(\zeta)-g(\zeta).$

\end{enumerate}
Note that items \ref{item:first}-\ref{item:last} can be viewed as rational equations evaluated at $\zeta$.
Let $E_1$ be the event that $E_0$ didn't occur, and one of the equations in steps \ref{item:first}-\ref{item:last}
doesn't hold as a rational identity. Multiplying denominators, we have from the Schwarz-Zippel Lemma that $E_1$ occurs with probability at most $2n/|\F| = \negl$ over $\zeta \in \F$.
Assuming $E_0$ and $E_1$ didn't occur we have that 

\begin{enumerate}
\item\label{item:firstX}
$ D(X) = X^{b-1} g(1/X)$,
\item \label{item:Sequation}
\[2(h(\alpha)+ \gamma v) =  g(X) \eqpol{u_1}(1/X) + g(1/X)\eqpol{u_1}(X) + \gamma(h(X) \eqpol{u_2}(1/X) + h(1/X) \eqpol{u_2}(X))\]
\[  - X S(X) - (1/X)S(1/X).\]
\item\label{item:lastX}$g(X) =  f(X)-(X^b-\alpha)q(X).$

\end{enumerate}
Let $E_2$ be the event that $E_0$ and $E_1$ don't occur but $\mle{g}(u_1)\neq h(\alpha)$ or $\mle{h}(u_2)\neq v$.
According to Claim \ref{claim:batchipa}, given the equation in item \ref{item:Sequation}, $E_2$ occurs with probability
at most $1/|\F|$ over $\gamma$.

Let $E_3$ be the event that $E_0\cup E_1 \cup E_2$ don't occur and
\begin{enumerate}
 \item 
$h(X)\neq \sumi{b}\eq(i,u_1) f_i(X)$,
\item $h(\alpha)= \sumi{b}\eq(i,u_1) f_i(\alpha)$.
\end{enumerate}
Obviously, $E_3$ has probability \negl.

Assume  $E_0\cup E_1 \cup E_2\cup E_3$ doesn't occur. We show that $\mle{f}(u)=v$, and thus we are outside the event $A$.
In other words, $A\subset E_0\cup E_1 \cup E_2 \cup E_3$.


Since
$ D(X) = X^{b-1} g(1/X)$ we know that $\deg(g)<b$.
Since  $g(X) =  f(X)-(X^b-\alpha)q(X)$, from Claim \ref{clm:univariatemod} we know that
$g(X)=\sumi{b}f_i(\alpha)X^i$.
Hence, we know that 
\[\mle{g}(u_1) = \sumi{b}\eq(i,u_1) f_i(\alpha) = h(\alpha).\]
Using $\neg E_3$ we  know that
$h(X)=\sumi{b}\eq(i,u_1) f_i(X)$.
Hence, writing $h(X)=\sumj{b}h_j X^j$ we have 
$h_j= \sumi{b}\eq(i,u_1) f_{i,j}$.
Thus, we have
\[\mle{f}(u) = \sumi{b}\sumj{b}\eq(i,u_1)\eq(j,u_2) f_{i,j} = \sumj{b}\eq(j,u_2) \sumi{b}\eq(i,u_1) f_{i,j} \]
\[=\sumj{b} \eq(j,u_2) h_j = \mle{h}(u_2) = v.\]

\section*{Acknowledgements}
We thank Benedikt B{\"{u}}nz for comments.
\bibliographystyle{alpha}
\bibliography{references}
\end{document}

