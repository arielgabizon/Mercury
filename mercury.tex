\documentclass[11pt]{article} % use larger type; default would be 10pt
\usepackage{hyperref}
\usepackage{fullpage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% packages
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={3.0},
]{doclicense}
\usepackage{authblk}
\usepackage[utf8]{inputenc} % set input encoding (not needed with xelatex)
\usepackage[strict]{changepage}
\usepackage{bold-extra}
    %%% examples of article customizations
    % these packages are optional, depending whether you want the features they provide.
    % see the latex companion or other references for full information.


    %%% page dimensions
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (us) or a5paper or....
%     \geometry{margin=2in} % for example, change the margins to 2 inches all round
    % \geometry{landscape} % set up the page for landscape
    %   read geometry.pdf for detailed page layout information
 \usepackage{numdef}

\usepackage{graphicx} % support the \includegraphics command and options
    % some of the article customisations are relevant for this class
\usepackage{amsmath,amsthm,calligra}
\usepackage{amsfonts} % math fonts such as \mathbb{}
\usepackage{amssymb} % \therefore
% \usepackage{bickham}
\usepackage{cryptocode}
\usepackage{framed}
    % \usepackage[parfill]{parskip} % activate to begin paragraphs with an empty line rather than an indent

    %%% packages
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. Enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
    % % these packages are all incorporated in the memoir class to one degree or another...
\usepackage{mathrsfs}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{adjustbox}
% \usepackage{pzccal}
% \DeclareFontFamily{OT1}{pzc}{}
% \DeclareFontShape{OT1}{pzc}{m}{it}{<-> s * [1.10] pzcmi7t}{}
% \DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}
\usepackage{pgfplots}

\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}

    %%% headers & footers
\usepackage{fancyhdr} % this should be set after setting up the page geometry
\pagestyle{fancy} % options: empty, plain, fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}


    %%% section title appearance
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (see the fntguide.pdf for font help)
    % (this matches context defaults)

    %%% toc (table of contents) appearance
\usepackage[nottoc,notlof,notlot]{tocbibind} % put the bibliography in the toc
\usepackage[titles,subfigure]{tocloft} % alter the style of the table of contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % no bold!
\usepackage[scr=esstix]  % heavily sloped
%             cal=esstix]   % slightly sloped
           {mathalpha}
 %%% end article customizations

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % macros
 \newcommand{\code}[1]{\texttt{#1}}
\newcommand\tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\newcommand\bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut
\newcommand{\bgamma}{\boldsymbol{\gamma}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
\newcommand{\plonk}{\ensuremath{\mathcal{P} \mathfrak{lon}\mathcal{K}}\xspace}
\newcommand{\gemini}{\ensuremath{\mathsf{gemini}}\xspace}
\newcommand{\zeromorph}{\ensuremath{\mathsf{zeromorph}}\xspace}
\newcommand{\mercury}{\ensuremath{\mathpgoth{MERCURY} }\xspace}
\newcommand{\cq}{\ensuremath{\mathpgoth{cq}}\xspace}
\newcommand{\cqlin}{\ensuremath{\mathpgoth{cq}\mathscr{\text{\calligra{lin}}}}\xspace}
\newcommand{\cqstar}{\ensuremath{\mathpgoth{cq^{\mathbf{*}}}}\xspace}
\newcommand{\protogal}{{\normalfont\scshape Proto\bfseries{galaxy}}\xspace}
\newcommand{\stackproofs}{s{\ensuremath{\mathfrak{t} \mathpgoth {ack}}\bfseries{proofs}}\xspace}
\newcommand{\protostar}{{\scshape Protostar}\xspace}
\newcommand{\hypernova}{{HyperNova}\xspace}
\newcommand{\flookup}{\ensuremath{\mathsf{\mathpgoth{Flookup}}}\xspace}
\newcommand{\baloo}{\ensuremath{\mathrm{ba}\mathit{loo}}\xspace}
\newcommand{\caulkp}{\ensuremath{\mathsf{\mathrel{Caulk}\mathrel{\scriptstyle{+}}}}\xspace}
\newcommand{\caulk}{\ensuremath{\mathsf{Caulk}}\xspace}
\newcommand{\plookup}{\ensuremath{\mathpgoth{plookup}}\xspace}
\newcommand{\tablegroup}{\ensuremath{\mathbb{H}}\xspace}
\newcommand{\V}{\ensuremath{\mathbf{V}}\xspace}
\newcommand{\relbase}{\ensuremath{\rel_0}\xspace}
\mathchardef\mhyphen="2D


\newcommand{\instbase}{\ensuremath{\inst_0}\xspace}
\newcommand{\witbase}{\ensuremath{\wit_0}\xspace}


\newcommand{\papertitle}{\mercury: A multilinear Polynomial Commitment Scheme with constant proof size and no prover FFTs}

\newcommand{\company}{}
\title{ \bf \papertitle \\[0.72cm]}
\author{ Liam Eagen \\ \tt{Alpen Labs}   \and Ariel Gabizon \\ \tt{Aztec Labs} } 

% otherwise the current date is printed
\DeclareMathAlphabet{\mathpgoth}{OT1}{pgoth}{m}{n}
\ProvidesPackage{numdef}



%% Ariel Macros:
% \num\newcommand{\G1}{\ensuremath{{\mathbb G}_1}\xspace}
\newcommand{\Gi}{\ensuremath{{\mathbb G}_i}\xspace}
\newcommand{\G}{\ensuremath{{\mathbb G}}\xspace}
\newcommand{\Gstar}{\ensuremath{{\mathbb G}^*}\xspace}
\newcommand{\x}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\z}{\ensuremath{\mathbf{z}}\xspace}
\newcommand{\X}{\ensuremath{\mathbf{X}}\xspace}

% \num\newcommand{\G2}{\ensuremath{{\mathbb G}_2}\xspace}
%\num\newcommand{\G11}{\ensuremath{\G1\setminus \set{0}}\xspace}
%\num\newcommand{\G21}{\ensuremath{\G2\setminus \set{0}}\xspace}
\newcommand{\grouppair}{\ensuremath{G^*}\xspace}
\newcommand{\prvperm}{\ensuremath{\mathrm{P_{\mathsf{\sigma}}}}\xspace}
\newcommand{\verperm}{\ensuremath{\mathrm{V_{\mathsf{\sigma}}}}\xspace}
\newcommand{\alg}{\ensuremath{\mathscr{A}}\xspace}

\newcommand{\Gt}{\ensuremath{{\mathbb G}_t}\xspace}
\newcommand{\F}{\ensuremath{\mathbb F}\xspace}
\newcommand{\Fstar}{\ensuremath{\mathbb F^*}\xspace}

\newcommand{\help}[1]{$#1$-helper\xspace}
\newcommand{\randompair}[1]{\ensuremath{\mathsf{randomPair}(#1)}\xspace}
\newcommand{\pair}[1]{$#1$-pair\xspace}
\newcommand{\pairs}[1]{$#1$-pairs\xspace}
\newcommand{\chalpoint}{\ensuremath{\mathfrak{z}}\xspace}

% \newcommand{\pairone}[1]{\G1-$#1$-pair\xspace}
% \newcommand{\pairtwo}[1]{\G2-$#1$-pair\xspace}
% \newcommand{\sameratio}[2]{\ensuremath{\mathsf{SameRatio}(#1,#2)}\xspace}
\newcommand{\vecc}[2]{\ensuremath{\left(#1\right)_{#2}}\xspace}
\newcommand{\players}{\ensuremath{[n]}\xspace}
\newcommand{\adv}{\ensuremath{\mathcal A}\xspace}
\newcommand{\advprime}{\ensuremath{\mathcal{A}'}\xspace}
\newcommand{\extprime}{\ensuremath{E'}\xspace}
\newcommand{\advrand}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
% \num\newcommand{\srs1}{\ensuremath{\mathsf{srs_1}}\xspace}
% \num\newcommand{\srs2}{\ensuremath{\mathsf{srs_2}}\xspace}
\newcommand{\srs}{\ensuremath{\mathsf{srs}}\xspace}
\newcommand{\regsrs}[1]{\ensuremath{\sett{\enc1{x^i}}{i\in \set{0,\ldots,#1-1}}}\xspace}
\newcommand{\srsm}{\ensuremath{\mathsf{srs}_M}\xspace}
\newcommand{\ext}{\ensuremath{E}\xspace}
\newcommand{\srsbase}{\ensuremath{\mathsf{srs_0}}\xspace}
\newcommand{\srsi}{\ensuremath{\mathsf{srs_i}}\xspace}
\newcommand{\com}{\ensuremath{\mathsf{com}}\xspace}
\newcommand{\comperm}{\ensuremath{\mathsf{com_{\sigma}}}\xspace}
\newcommand{\cm}{\ensuremath{\mathsf{cm}}\xspace}
\newcommand{\cmsig}{\ensuremath{\mathsf{cm_\sigma}}\xspace}
\newcommand{\open}{\ensuremath{\mathsf{open}}\xspace}
\newcommand{\openperm}{\ensuremath{\mathsf{open_{\sigma}}}\xspace}
\newcommand{\sigof}[1]{\ensuremath{\sigma(#1)}\xspace}
\newcommand{\proverexp}{\ensuremath{\mathsf{e}}\xspace}
\newcommand{\reducedelems}{\ensuremath{\mathsf{r}}\xspace}

\newcommand{\ci}{\ensuremath{\mathrm{CI}}\xspace}
\renewcommand{\deg}{\ensuremath{\mathrm{deg}}\xspace}
\newcommand{\pairvec}[1]{$#1$-vector\xspace}
\newcommand{\Fq}{\ensuremath{\mathbb{F}_q}\xspace}
\newcommand{\randpair}[1]{\ensuremath{\mathsf{rp}_{#1}}\xspace}
\newcommand{\randpairone}[1]{\ensuremath{\mathsf{rp}_{#1}^{1}}\xspace}
\newcommand{\negl}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\randpairtwo}[1]{\ensuremath{\mathsf{rp_{#1}^2}}\xspace}%the randpair in G2
% \newcommand{\nilp}{\ensuremath{\mathscr N}\xspace}
% \newcommand{\groupgen}{\ensuremath{\mathscr G}\xspace}
% \newcommand{\qap}{\ensuremath{\mathscr Q}\xspace}
\newcommand{\polprot}[4]{$(#1,#2,#3,#4)$-polynomial protocol}
\newcommand{\rangedprot}[5]{$#5$-ranged $(#1,#2,#3,#4)$-polynomial protocol}

\newcommand{\rej}{\shlomomath{reject}}
\newcommand{\accept}{\ensuremath{\mathsf{accept}}\xspace}
\newcommand{\res}{\ensuremath{\mathsf{res}}\xspace}
% \newcommand{\sha}[1]{\ensuremath{\mathsf{COMMIT}(#1)}\xspace}
%  \newcommand{\shaa}{\ensuremath{\mathsf{COMMIT}}\xspace}
 \newcommand{\comm}[1]{\ensuremath{\enc1{#1(x)}}\xspace}
 \newcommand{\defeq}{:=}

\newcommand{\dom}{\ensuremath{H}\xspace}
\newcommand{\C}{\ensuremath{\vec{C}}\xspace}
\newcommand{\randadv}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
 \num\newcommand{\ex1}[1]{\ensuremath{#1\cdot g_1}\xspace}
 \num\newcommand{\ex2}[1]{\ensuremath{#1\cdot g_2}\xspace}
 \newcommand{\pr}{\mathrm{Pr}}
%  \newcommand{\powervec}[2]{\ensuremath{(1,#1,#1^{2},\ldots,#1^{#2})}\xspace}
%  \newcommand{\partition}{\ensuremath{\mathcal{T}}\xspace}
%  \newcommand{\partof}[1]{\ensuremath{{\partition_{#1}}}\xspace}
% \num\newcommand{\out1}[1]{\ensuremath{\ex1{\powervec{#1}{d}}}\xspace}
% \num\newcommand{\out2}[1]{\ensuremath{\ex2{\powervec{#1}{d}}}\xspace}
%  \newcommand{\nizk}[2]{\ensuremath{\mathrm{NIZK}(#1,#2)}\xspace}% #2 is the hash concatenation input
%  \newcommand{\verifynizk}[3]{\ensuremath{\mathrm{VERIFY\mhyphen NIZK}(#1,#2,#3)}\xspace}
\newcommand{\protver}{protocol verifier\xspace}
\newcommand{\hash}{\ensuremath{\mathcal{H}}\xspace}
\newcommand{\mulgroup}{\ensuremath{\F^*}\xspace}
\newcommand{\lag}[1]{\ensuremath{L_{#1}}\xspace}
\newcommand{\sett}[2]{\ensuremath{\set{#1}_{#2}}\xspace}
\newcommand{\omegaprod}{\ensuremath{\alpha_{\omega}}\xspace}
\newcommand{\lagvec}[1]{\ensuremath{\mathrm{LAG}_{#1}}\xspace}
\newcommand{\trapdoor}{\ensuremath{r}}
\newcommand{\trapdoorext}{\ensuremath{r_{\mathrm{ext}}}\xspace}
% \newcommand{\trapdoorsim}{\ensuremath{r_{\mathrm{sim}}}\xspace}
\renewcommand{\sim}{\ensuremath{\mathrm{S}}\xspace}
\renewcommand{\mod}{\ensuremath{\;\mathrm{mod}\;}}
\newcommand{\hsub}{\ensuremath{H^*}\xspace}
% \num\newcommand{\enc1}[1]{\ensuremath{\left[#1\right]_1}\xspace}
\newcommand{\enci}[1]{\ensuremath{\left[#1\right]_i}\xspace}
% \num\newcommand{\enc2}[1]{\ensuremath{\left[#1\right]_2}\xspace}

\newcommand{\enc}[1]{\ensuremath{\left[#1\right]_1}\xspace}
\newcommand{\enctwo}[1]{\ensuremath{\left[#1\right]_2}\xspace}
\newcommand{\gen}{\ensuremath{\mathsf{gen}}\xspace}
\newcommand{\hgen}{\ensuremath{\omega}\xspace}
\newcommand{\gops}{\G1-operations\xspace}
\newcommand{\nlogngops}{$O(n\log n)$ \G1-operations\xspace}
\newcommand{\nlognfops}{$O(n\log n)$ \F-operations\xspace}
\newcommand{\fops}{\F-operations\xspace}
\newcommand{\prv}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\prvpoly}{\ensuremath{\mathrm{P_{\mathsf{poly}}}}\xspace}
\newcommand{\prvpc}{\ensuremath{\mathrm{P_{\mathsf{PC}}}}\xspace}
\newcommand{\verpoly}{\ensuremath{\mathrm{V_{\mathsf{poly}}}}\xspace}
\newcommand{\verpc}{\ensuremath{\mathrm{V_{\mathsf{PC}}}}\xspace}
\newcommand{\ideal}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\prf}{\ensuremath{\mathsf{\pi}}\xspace}
\newcommand{\prfone}{\ensuremath{\mathsf{\pi_1}}\xspace}
% \newcommand{\simprv}{\ensuremath{\mathrm{P^{sim}}}\xspace}

%\newcommand{\enc}[1]{\ensuremath{\left[#1\right]}\xspace}
%\num\newcommand{\G0}{\ensuremath{\mathbf{G}}\xspace}
\newcommand{\GG}{\ensuremath{\mathbf{G^*}}\xspace}  % would have liked to call this G01 but problem with name
\num\newcommand{\g0}{\ensuremath{\mathbf{g}}\xspace}
\newcommand{\inst}{\ensuremath{\phi}\xspace}
\newcommand{\newinst}{\ensuremath{\phi^*}\xspace}
\newcommand{\row}{\ensuremath{\mathsf{R}}\xspace}
\newcommand{\col}{\ensuremath{\mathsf{C}}\xspace}
\newcommand{\inp}{\ensuremath{\mathsf{x}}\xspace}
\newcommand{\wit}{\ensuremath{\mathsf{\omega}}\xspace}
\newcommand{\eps}{\ensuremath{\varepsilon}\xspace}
\newcommand{\inpF}{\ensuremath{\mathscr{x}}\xspace}
\newcommand{\witF}{\ensuremath{\mathscr{w}}\xspace}
\newcommand{\instFprime}{\ensuremath{\inst}\xspace}%\mathpgoth{x}}\xspace}
\newcommand{\witFprime}{\ensuremath{\witinst}\xspace}%\mathpgoth{w}}\xspace}
\newcommand{\acchash}{\ensuremath{\mathscr{h}}\xspace}
\newcommand{\accnew}{\ensuremath{\mathscr{acc}}\xspace}
\newcommand{\cnt}{\ensuremath{\mathsf{count}}\xspace}
\newcommand{\ver}{\ensuremath{\mathsf{\mathbf{V}}}\xspace}
\newcommand{\verpg}{\ensuremath{\ver^{\predinst,\cm}_{PG}}\xspace}
\newcommand{\per}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\perpg}{\ensuremath{\per_{PG}}\xspace}
\newcommand{\sonic}{\ensuremath{\mathsf{Sonic}}\xspace}
\newcommand{\aurora}{\ensuremath{\mathsf{Aurora}}\xspace}
\newcommand{\auroralight}{\ensuremath{\mathsf{Auroralight}}\xspace}
\newcommand{\groth}{\ensuremath{\mathsf{Groth'16}}\xspace}
\newcommand{\kate}{\ensuremath{\mathsf{KZG}}\xspace}
\newcommand{\rel}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\relrand}{\ensuremath{\mathcal{R^{\mathsf{rand}}}}\xspace}
\newcommand{\lang}{\ensuremath{\mathcal{L}}\xspace}
\newcommand{\params}{\ensuremath{\mathsf{params}_{\inst}}\xspace}
\newcommand{\protparams}{\ensuremath{\mathsf{params}_{\inst}^\advv}\xspace}
\num\newcommand{\p1}{\ensuremath{P_1}\xspace}
\newcommand{\advv}{\ensuremath{\mathcal{A}^{\mathbf{*}}}\xspace} % the adversary that uses protocol adversary as black box
\newcommand{\crs}{\ensuremath{\sigma}\xspace}
%\num\newcommand{\crs1}{\ensuremath{\mathrm{\sigma}_1}\xspace}
%\num\newcommand{\crs2}{\ensuremath{\mathrm{\sigma}_2}\xspace}
\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace}
% \newcommand{\hgen}{\ensuremath{\mathbf{\omega}}\xspace}
\newcommand{\vgen}{\ensuremath{\mathbf{g}}\xspace}
% \renewcommand{\sim}{\ensuremath{\mathsf{sim}}\xspace}%the distribution of messages when \advv simulates message of \p1
\newcommand{\real}{\ensuremath{\mathsf{real}}\xspace}%the distribution of messages when \p1 is honest and \adv controls rest of players
 \newcommand{\koevec}[2]{\ensuremath{(1,#1,\ldots,#1^{#2},\alpha,\alpha #1,\ldots,\alpha #1^{#2})}\xspace}
\newcommand{\mida}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\midb}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\midc}{\ensuremath{C_{\mathrm{mid}}}\xspace}
\newcommand{\chal}{\ensuremath{\mathsf{challenge}}\xspace}
\newcommand{\attackparams}{\ensuremath{\mathsf{params^{pin}}}\xspace}
\newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\attackdist}[2]{\ensuremath{AD_{#1}}\xspace}
% \renewcommand{\neg}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\ro}{\ensuremath{{\mathscr R}}\xspace}
\newcommand{\elements}[1]{\ensuremath{\mathsf{elements}_{#1}}\xspace}
 \num\newcommand{\elmpowers1}[1]{\ensuremath{\mathrm{\mathsf{e}}^1_{#1}}\xspace}
 \num\newcommand{\elmpowers2}[1]{\ensuremath{\mathrm{\mathsf{e}}^2_{#1}}\xspace}
\newcommand{\elempowrs}[1]{\ensuremath{\mathsf{e}_{#1}}\xspace}
 \newcommand{\secrets}{\ensuremath{\mathsf{secrets}}\xspace}
 \newcommand{\polysofdeg}[1]{\ensuremath{\F_{< #1}[X]}\xspace}
 \newcommand{\polysofdegeq}[1]{\ensuremath{\F_{\leq #1}[X]}\xspace}
 \newcommand{\polys}{\ensuremath{\F[X]}\xspace}
 \newcommand{\bivar}[1]{\ensuremath{\F_{< #1}[X,Y]}\xspace}
 \newcommand{\sig}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\prot}{\ensuremath{\mathscr{P}}\xspace}
 \newcommand{\protstar}{\ensuremath{\mathscr{P}^*}\xspace}
 \newcommand{\PCscheme}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\protprime}{\ensuremath{\mathscr{P^*}}\xspace}
 \newcommand{\sigprv}{\ensuremath{\mathsf{P_{sc}}}\xspace}
 \newcommand{\sigver}{\ensuremath{\mathsf{V_{sc}}}\xspace}
 \newcommand{\sigpoly}{\ensuremath{\mathsf{S_{\sigma}}}\xspace}
 \newcommand{\idpoly}{\ensuremath{\mathsf{S_{ID}}}\xspace}
\newcommand{\idpolyevala}{\ensuremath{\mathsf{\bar{s}_{ID1}}}\xspace}
\newcommand{\sigpolyevala}{\ensuremath{\mathsf{\bar{s}_{\sigma1}}}\xspace}
\newcommand{\sigpolyevalb}{\ensuremath{\mathsf{\bar{s}_{\sigma2}}}\xspace}
\newcommand{\bctv}{\ensuremath{\mathsf{BCTV}}\xspace}
\newcommand{\PI}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\PIb}{\ensuremath{\mathsf{PI_B}}\xspace}
\newcommand{\PIc}{\ensuremath{\mathsf{PI_C}}\xspace}
\newcommand{\dl}[1]{\ensuremath{\widehat{#1}}\xspace}
\newcommand{\obgen}{\ensuremath{\mathcal O}\xspace}
\newcommand{\PC}{\ensuremath{\mathscr{P}}\xspace}
\newcommand{\permscheme}{\ensuremath{\sigma_\mathscr{P}}\xspace}


\newcommand{\selleft}{\ensuremath{\mathbf{q_L}}\xspace}
\newcommand{\selright}{\ensuremath{\mathbf{q_R}}\xspace}
\newcommand{\selout}{\ensuremath{\mathbf{q_O}}\xspace}
\newcommand{\selmult}{\ensuremath{\mathbf{q_M}}\xspace}
\newcommand{\selconst}{\ensuremath{\mathbf{q_C}}\xspace}
\newcommand{\selectors}{\ensuremath{\mathcal{Q}}\xspace}
\newcommand{\lvar}{\ensuremath{\mathbf{a}}\xspace}
\newcommand{\vars}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\rvar}{\ensuremath{\mathbf{b}}\xspace}
\newcommand{\ovar}{\ensuremath{\mathbf{c}}\xspace}
\newcommand{\pubvars}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\assignment}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\constsystem}{\ensuremath{\mathscr{C}}\xspace}
\newcommand{\relof}[1]{\ensuremath{\rel_{#1}}\xspace}
\newcommand{\pubinppoly}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\sumi}[1]{\sum_{i< #1}}
\newcommand{\sumzertok}[1]{\sum_{#1=0}^{k}}
\newcommand{\sumpoly}[1]{\sum_{i=0}^{#1-1}}
\newcommand{\summ}[1]{\sum_{i\in[#1]}}
\newcommand{\sumj}[1]{\sum_{j< #1}}
\newcommand{\innerprod}[2]{\langle#1,#2\rangle}
\newcommand{\ZeroH}{\ensuremath{Z_H} \xspace}
\newcommand{\lpoly}{\ensuremath{\mathsf{a}}\xspace}
\newcommand{\rpoly}{\ensuremath{\mathsf{b}}\xspace}
\newcommand{\opoly}{\ensuremath{\mathsf{c}}\xspace}
\newcommand{\idpermpoly}{\ensuremath{\mathsf{z}}\xspace}
\newcommand{\lagrangepoly}{\ensuremath{\mathsf{L}}\xspace}
\newcommand{\zeropoly}{\ensuremath{\mathsf{\ZeroH}}\xspace}
\newcommand{\selmultpoly}{\ensuremath{\mathsf{q_M}}\xspace}
\newcommand{\selleftpoly}{\ensuremath{\mathsf{q_L}}\xspace}
\newcommand{\selrightpoly}{\ensuremath{\mathsf{q_R}}\xspace}
\newcommand{\seloutpoly}{\ensuremath{\mathsf{q_O}}\xspace}
\newcommand{\selconstpoly}{\ensuremath{\mathsf{q_C}}\xspace}
\newcommand{\idcomm}{\ensuremath{[s_{\mathsf{ID1}}]_1}\xspace}
\newcommand{\sigcomma}{\ensuremath{[s_{\mathsf{\sigma1}}]_1}\xspace}
\newcommand{\sigcommb}{\ensuremath{[s_{\mathsf{\sigma2}}]_1}\xspace}
\newcommand{\sigcommc}{\ensuremath{[s_{\mathsf{\sigma3}}]_1}\xspace}
\newcommand{\selleftcomm}{\ensuremath{[q_\mathsf{L}]_1}\xspace}
\newcommand{\selrightcomm}{\ensuremath{[q_\mathsf{R}]_1}\xspace}
\newcommand{\seloutcomm}{\ensuremath{[q_\mathsf{O}]_1}\xspace}
\newcommand{\selconstcomm}{\ensuremath{[q_\mathsf{C}]_1}\xspace}
\newcommand{\selmultcomm}{\ensuremath{[q_\mathsf{M}]_1}\xspace}

\newcommand{\multlinecomment}[1]{\directlua{-- #1}}


\newtheorem{lemma}{Lemma}[section]
\newtheorem{thm}[lemma]{Theorem}
\newtheorem{dfn}[lemma]{Definition}
\newtheorem{remark}[lemma]{Remark}

\newtheorem{claim}[lemma]{Claim}
\newtheorem{corollary}[lemma]{Corollary}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\crct}{\ensuremath{\mathsf{C}}\xspace}
\newcommand{\A}{\ensuremath{\mathcal{A}}\xspace}
%\newcommand{\G}{\mathcal{G}}
\newcommand{\Gr}{\mathbb{G}}
%\newcommand{\com}{\textsf{com}}  Ariel defined equivalent that also works in math mode
\newcommand{\cgen}{\text{cgen}}
\newcommand{\poly}{\ensuremath{\mathsf{poly(\lambda)}}\xspace}
\newcommand{\snark}{\ensuremath{\mathsf{snark}}\xspace}
\newcommand{\grandprod}{\mathsf{prod}}
\newcommand{\perm}{\mathsf{S}}
%\newcommand{\open}{\mathsf{open}}
\newcommand{\update}{\mathsf{update}}
\newcommand{\Prove}{\mathcal{P}}
\newcommand{\Verify}{\mathcal{V}}
\newcommand{\Extract}{\mathcal{E}}
\newcommand{\Simulate}{\mathcal{S}}
\newcommand{\Unique}{\mathcal{U}}
\newcommand{\Rpoly}{\R{\poly}}
\newcommand{\Ppoly}{\Prove{\poly}}
\newcommand{\Vpoly}{\Verify{\poly}}
\newcommand{\Psnark}{\prv}%{\Prove{\snark}}
\newcommand{\Vsnark}{\ver}%{\Verify{\snark}}
\newcommand{\Rprod}{\R{\grandprod}}
\newcommand{\Pprod}{\Prove{\grandprod}}
\newcommand{\Vprod}{\Verify{\grandprod}}
\newcommand{\Rperm}{\R{\perm}}
\newcommand{\Pperm}{\Prove{\perm}}
\newcommand{\Vperm}{\Verify{\perm}}
% \newcommand{\zw}[1]{{\textcolor{magenta}{Zac:#1}}}
\newcommand{\ag}[1]{{\textcolor{blue}{\emph{Ariel:#1}}}}
\newcommand{\extprot}{\ensuremath{E_{\prot}}\xspace}
\newcommand{\transcript}{\ensuremath{\mathsf{transcript}}\xspace}
\newcommand{\extpc}{\ensuremath{E_{\PCscheme}}\xspace}
\newcommand{\advpc}{\ensuremath{\mathcal A_{\PCscheme}}\xspace}
\newcommand{\advprot}{\ensuremath{\mathcal A_{\prot}}\xspace}
\newcommand{\protmany}{\ensuremath{\prot_k}\xspace}

\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\marlin}{\ensuremath{\mathsf{Marlin}}\xspace}
\newcommand{\fractal}{\ensuremath{\mathsf{Fractal}}\xspace}
% \newcommand{\Rsnark}{\R{\snark}}
\newcommand{\Rsnark}{\R}
\newcommand{\subvec}[1]{\ensuremath{#1|_{\subspace}}\xspace}
\newcommand{\restricttovec}[1]{\ensuremath{#1|_{\subgroup}}\xspace}
\newcommand{\isinvanishing}[1]{\ensuremath{\mathsf{IsInVanishing_{\subspace,#1}}}\xspace}
\newcommand{\batchedisinvanishing}[1]{\ensuremath{\mathsf{BatchedIsInVanishing_{\subspace,#1}}}\xspace}
\newcommand{\isconsistent}{\ensuremath{\mathsf{IsConsistent}}\xspace}
\newcommand{\isintable}{\ensuremath{\mathsf{IsInTable}}\xspace}
\newcommand{\lincheck}{\ensuremath{\mathsf {lincheck}}\xspace}
\newcommand{\accprot}{\ensuremath{\mathsf {accProt}}\xspace}
\newcommand{\isinvanishingtable}[1]{\ensuremath{\mathsf{IsInVanishingTable_{\subspace,#1}}}\xspace}
\newcommand{\isvanishingsubtable}[1]{\ensuremath{\mathsf{IsVanishingSubtable_{#1}}}\xspace}
\newcommand{\haslowerdegree}{\ensuremath{\mathsf{HasLowerDegree}}\xspace}
\newcommand{\haslowdegree}[1]{\ensuremath{\mathsf{HasLowDegree_{#1}}}\xspace}
\newcommand{\issubtable}[1]{\ensuremath{\mathsf{IsSubtable_{#1}}}\xspace}
\newcommand{\isinsubtable}[2]{\ensuremath{\mathsf{IsInSubtable_{#1,#2}}}\xspace}
\newcommand{\secbasezero}[1]{\ensuremath{\hat{\tau}_{#1}}\xspace}
\newcommand{\secbase}[1]{\ensuremath{\hat{\tau}_{#1}}\xspace}
\newcommand{\secbasereg}[1]{\ensuremath{\tau_{#1}}\xspace}
\newcommand{\secset}{\ensuremath{I}\xspace}
\newcommand{\pubbase}[1]{\ensuremath{\mu_{#1}}\xspace}
\newcommand{\subspace}{\ensuremath{\mathbb{H}}\xspace}
\newcommand{\subgroup}{\ensuremath{\mathbb{H}}\xspace}
\newcommand{\biggroup}{\ensuremath{\mathbb{V}}\xspace}
\newcommand{\subtable}{\ensuremath{T_0}\xspace}
\newcommand{\tablelang}{\ensuremath{\lang_T}\xspace}
\newcommand{\vanishingtablelang}{\ensuremath{\lang_{\subspace}}\xspace}
\newcommand{\nonorm}[1]{\ensuremath{\Gamma^T_{#1}}\xspace}
\newcommand{\unnorm}[2]{\ensuremath{\Gamma^{#1}_{#2}}\xspace}
\newcommand{\bigspacebase}{\ensuremath{\lambda}\xspace}
\newcommand{\bigspacegen}{\ensuremath{\mathsf{h}}\xspace}
\newcommand{\modvan}[1]{\ensuremath{\mathrm{mod\;}Z_{#1}}\xspace}
\newcommand{\extractevaltable}{\ensuremath{\mathsf{ExtractEvalTable}_{C,\tablegroup}}\xspace}
\newcommand{\witsize}{\ensuremath{n}\xspace}
\newcommand{\witruntime}{\ensuremath{\witsize\log\witsize}\xspace}
\newcommand{\tabsize}{\ensuremath{N}\xspace}
\newcommand{\tabruntime}{\ensuremath{\tabsize\log\tabsize}\xspace}
\newcommand{\tab}{\ensuremath{\mathfrak{t}}\xspace}
 \renewcommand{\a}{\ensuremath{\mathsf{a}}\xspace}
\renewcommand{\b}{\ensuremath{\mathsf{b}_0}\xspace}
\renewcommand{\c}{\ensuremath{\mathsf{c}}\xspace}
\newcommand{\vc}{\ensuremath{\mathsf{c_v}}\xspace}
\renewcommand{\v}{\ensuremath{\mathsf{v}}\xspace}
\renewcommand{\r}{\ensuremath{\mathsf{r}}\xspace}
\newcommand{\h}{\ensuremath{\mathsf{h}}\xspace}
\renewcommand{\d}{\ensuremath{\mathsf{d}}\xspace}
\newcommand{\f}{\ensuremath{\mathsf{f}}\xspace}
\renewcommand{\g}{\ensuremath{\mathsf{g}}\xspace}
\newcommand{\matrices}{\ensuremath{\F^{n\times n}}\xspace}
\newcommand{\ftwo}{\ensuremath{\mathsf{f}_2}\xspace}
\renewcommand{\p}{\ensuremath{\mathsf{p}}\xspace}
\newcommand{\q}{\ensuremath{\mathsf{q}}\xspace}
\newcommand{\qone}{\ensuremath{\mathsf{q_1}}\xspace}
\newcommand{\s}{\ensuremath{\mathsf{s}}\xspace}
\newcommand{\qa}{\ensuremath{\mathsf{q_a}}\xspace}
\newcommand{\qb}{\ensuremath{\mathsf{q_b}}\xspace}
\newcommand{\m}{\ensuremath{\mathsf{m}}\xspace}
\newcommand{\agam}{\ensuremath{a_\gamma}\xspace}
\newcommand{\gamproof}{\ensuremath{\mathsf{\pi_\gamma}}\xspace}
\newcommand{\zerproof}{\ensuremath{\mathsf{\a}_0}\xspace}
\newcommand{\bgam}{\ensuremath{b_\gamma}\xspace}
\newcommand{\bzergam}{\ensuremath{b_{0,\gamma}}\xspace}
\newcommand{\qbgam}{\ensuremath{Q_{b,\gamma}}\xspace}
\newcommand{\zgam}{\ensuremath{Z_{\bigspace,\gamma}}\xspace}
\newcommand{\betaa}{\ensuremath{\mathbf{\boldsymbol{\beta}}}\xspace}
\newcommand{\deltaa}{\ensuremath{\mathbf{\boldsymbol{\delta}}}\xspace}
\newcommand{\gammaa}{\ensuremath{\mathbf{\boldsymbol{\gamma}}}\xspace}
\newcommand{\witcom}{\ensuremath{\mathsf{W}}\xspace}
\newcommand{\instt}{\ensuremath{\Phi^*}\xspace}
\newcommand{\insttbase}{\ensuremath{\Phi}\xspace}
\newcommand{\pow}{\ensuremath{\mathsf{pow}}\xspace}
\newcommand{\eq}{\ensuremath{\mathsf{eq}}\xspace}
\newcommand{\FFT}{\ensuremath{\mathsf{FFT}}\xspace}
\newcommand{\fgam}{\ensuremath{f_{\gamma}}\xspace}
\newcommand{\pgam}{\ensuremath{P_{\gamma}}\xspace}
\newcommand{\supp}[1]{\ensuremath{\mathrm{supp}(#1)}\xspace}
\newcommand{\degoffset}{\ensuremath{\tabsize-1-(\witsize-2)}\xspace}
\newcommand{\modpoly}[1]{\ensuremath{\;\;\mod #1(X)}\xspace}
\newcommand{\coeff}[2]{\ensuremath{(#1)_{[#2]}}\xspace}
\newcommand{\kzg}[1]{\ensuremath{\mathsf{KZG}_{#1,\subgroup}}\xspace}
\newcommand{\accscheme}[2]{$(#1\mapsto #2)$-folding scheme\xspace}
\newcommand{\accrel}{\ensuremath{\rel_{\mathpgoth{acc}}}\xspace}
\newcommand{\relpair}{\ensuremath{\mathfrak{p}}\xspace}
\newcommand{\inststar}{\ensuremath{\inst^*}\xspace}
\newcommand{\witstar}{\ensuremath{\wit^*}\xspace}
\newcommand{\relpairstar}{\ensuremath{\relpair^*}\xspace}
\newcommand{\witt}{\ensuremath{\mathrm{w}}\xspace}
\newcommand{\nodelabel}{\ensuremath{\mathfrak{n}}\xspace}
\newcommand{\roundnum}{\ensuremath{\mathpgoth{k}}\xspace}
\newcommand{\manyvar}{\ensuremath{\mathfrak{J}}\xspace}
\newcommand{\nmin}{\ensuremath{[n]_0}\xspace}
\newcommand{\zfin}{\ensuremath{z_{\mathscr{final}}}\xspace}
\newcommand{\relapp}{\ensuremath{\rel_{app}}\xspace}
\newcommand{\relexec}{\ensuremath{\rel_{\mathrm{exec}}}\xspace}
\newcommand{\relF}{\ensuremath{\rel_F}\xspace}
\newcommand{\init}{\ensuremath{\mathsf{init}}\xspace}
\newcommand{\add}{\ensuremath{\mathsf{add}}\xspace}
\newcommand{\del}{\ensuremath{\mathsf{del}}\xspace}
\renewcommand{\read}{\ensuremath{\mathsf{read}}\xspace}
\newcommand{\countrange}{\ensuremath{[M]}\xspace}
\newcommand{\true}{\ensuremath{\mathsf{true}}\xspace}
\newcommand{\false}{\ensuremath{\mathsf{false}}\xspace}
\newcommand{\finstate}{\ensuremath{V}\xspace}
\newcommand{\ops}{\ensuremath{\mathcal{O}}\xspace}
\newcommand{\op}{\ensuremath{\mathscr{op}}\xspace}
\newcommand{\instapp}{\ensuremath{\mathfrak{x}}\xspace}
\newcommand{\witapp}{\ensuremath{\mathfrak{w}}\xspace}
\newcommand{\instnoops}{\ensuremath{\mathbf{x}}\xspace}
 \renewcommand{\path}{\ensuremath{\mathbf{p}}\xspace}
\renewcommand{\root}{\ensuremath{\mathbf{r}}\xspace}
\renewcommand{\eq}{\ensuremath{\mathbf{eq}}\xspace}
\newcommand{\eqpol}[1]{\ensuremath{P_{#1}}\xspace}
\newcommand{\mle}[1]{\ensuremath{\mathsf{ml}(#1)}\xspace}
\newcommand{\predinst}{\ensuremath{\mathpgoth{f}}\xspace}
\renewcommand{\empty}{\ensuremath{g_{\mathscr{empty}}}\xspace}
\newcommand{\funcs}{\ensuremath{\mathsf{F}}\xspace}
\newcommand{\prob}{\ensuremath{\mathsf{prob}}\xspace}
\newcommand{\ztafuncs}{\ensuremath{\mathcal{D}}\xspace}
\newcommand{\prodt}{\ensuremath{\prod_{i=1}^t}\xspace}
\newcommand{\B}[1]{\ensuremath{\set{0,1}^{#1}}\xspace}
\newcommand{\shlomomath}[1]{\ensuremath{\text{\usefont{U}{BOONDOX-cal}{m}{n}#1}}\xspace}
\newcommand{\acc}{\ensuremath{\shlomomath{accept}}\xspace}
\newcommand{\mlpcs}{ml-PCS\xspace}
\renewcommand{\zeta}{\mathfrak{z}}
\newcommand{\qzeta}{\ensuremath{q_{\zeta}}\xspace}
\newcommand{\fzeta}{\ensuremath{f_{\zeta}}\xspace}
\newcommand{\prfzeta}{\ensuremath{\prf_{\zeta}}\xspace}
\newcommand{\prfother}{\ensuremath{\prf'}\xspace}
\newcommand{\gzeta}{\ensuremath{g_{\zeta}}\xspace}
\newcommand{\dzeta}{\ensuremath{D_{\zeta}}\xspace}
\newcommand{\szeta}{\ensuremath{s_{\zeta}}\xspace}
\newcommand{\hzeta}{\ensuremath{h_{\zeta}}\xspace}
\newcommand{\ginv}{\ensuremath{\bar{g}_{\zeta}}\xspace}
\newcommand{\hinv}{\ensuremath{\bar{h}_{\zeta}}\xspace}
\newcommand{\sinv}{\ensuremath{\bar{s}_{\zeta}}\xspace}
\newcommand{\halpha}{\ensuremath{h_{\alpha}}\xspace}
% \newcommand{\instF}{\ensuremath{\mathrm{x}}\xspace}
% \newcommand{\witF}{\ensuremath{\mathrm{w}}\xspace}
\begin{document}
    \maketitle
\begin{abstract}
We construct a polynomial commitment scheme for multilinear polynomials  of size $n$ where
constructing an opening proof requires  $O(n)$ field operations, and $2n+O(\sqrt n)$ scalar multiplications. Moreover,
the opening proof consists of a constant number of field elements.
This is a significant improvement over previous works which would require either
\begin{enumerate}
 \item $O(n\log n)$ field operations; or
 \item $O(\log n)$ size opening proof.
\end{enumerate}
The main technical component is a new method of verifiably folding a witness via univariate polynomial division.
As opposed to previous methods, the proof size and prover time remain constant \emph{regardless of the folding factor}.
% a As opposed to more familiar folding methods - e.g. as used in the sumcheck protocol - this allows to fold the witness by a \emph{super-constant} factor with a \emph{linear} (rather than superlinear)  number of field operations and scalar multiplications.
\end{abstract}
\section{Introduction}


\subsection{Our results}
bl
blabla

\begin{table}[!htbp]
	\caption{ Comparison of pairing-based \mlpcs. }
	\centering
% \begin{adjustbox}{width=1\textwidth}
	\begin{tabular}{l|l|l|l}
	\thead{Scheme} & \thead{Proof size} & \thead{Prover Work} & \thead{Verifier Work}  \\ \hline
		univariate-based e.g. \cite{logupgkr}
		        & $O(1)$ \F &        $O(n\log n)$ \F,$O(n)$ \G  & $O(\log n)$ \F,   $O(1)$ \G   \\ \hline
		\gemini\cite{gemini} & $O(\log n)$ \F &  $O(n)$ \F, $3n$ \G     &    $O(\witsize^2)$ \F,\G1 \\ \hline
		
		\zeromorph\cite{zeromorph} & $O(\log n)$ \F             & $O(n)$ \F, $2.5n$ \G   & $6\witsize$ \G1, \witsize \G2, $O(\witsize\log^2\witsize)$ \F         \\ \hline
		\mercury\cite{mercury}       & $O(1)$ \F   & $O(n)$ \F, $2n+ O(\sqrt n)$ \G     & $13n$ \G1 $n$ \G2, $O(n\log^2n)$ \F          \\ \hline
	\end{tabular}
% \end{adjustbox}
\label{table:prover-work}
\end{table} 

\section{Overview of technique}
\begin{remark}
 In this overview, we use some of the notation defined in Sections \ref{sec:terminology} and \ref{sec:multilin-polys}.
\end{remark}

Our technique is best thought of as an improvement of the \mlpcs from \gemini \cite{gemini}.
Let us start by recalling how \gemini works.
\gemini commits to the multilinear function as a \emph{univariate} KZG commitment\cite{kzg}. Specifically,
suppose given a vector $f\in \F^n$, and a structured reference string of elements \sett{\enc{x^i}}{i<n}. \gemini
outputs $\sumi{n}f_i \enc{x^i}$ as a commitment to the multilinear function $M(X_0,\ldots,X_{s-1})= \sumi{n}\eq(i,u) f_i$ where $u\in \F^{\log n}$.
Now suppose prover \prv wants to convince verifier \ver  that $M(u)=v$, for some $u=(u_0,\ldots,u_{s-1})$. \prv will send commitments $\cm_1,\ldots,\cm_s$ to the $s$ incremental restrictions leading  to evaluation at $u$.
Namely, to $M_1(u_0,X_1,\ldots,X_{s-1})$, $M_2(u_0,u_1,X_2,\ldots,X_{s-1}),\ldots,M_s(u_0,\ldots,u_{s-1})$.
Assuming \prv sent commitments to the correct functions, all that is needed is to check that $\cm_s$ is the commitment to the constant $v$. Of course, the technically interesting part is to prove the commitments \emph{are} to the correct functions!
For this purpose, \gemini exploits a connection between $M$ and its corresponding univariate $f(X)$:
Write $f(X)=f_0(X^2)+X f_1(X^2)$, for $f_0(X),f_1(X)$ of degree $<n/2$. Let $f_{u_1}(X)$ be the univariate corresponding to $M_1$ defined above. Then, we have
\[f_{u_1}(X)=(1-u_1)f_0(X)+ u_1 f_1(X).\]
Additionally, we can evaluate $f_0$ and $f_1$ via $f$  using the equations
\[f_0(X^2)=(f(X)+f(-X))/2, f_1(X^2)=(f(X)-f(-X))/2x\]
Thus, we can perform consistency checks between each pair $\cm_{i-1},\cm_i$ showing it is the correct restriction to the next variable.
Of course, we get $O(s)=O(\log n)$ proof length due to sending this incremental sequence of restrictions.
Here is a first idea on how to reduce proof length (without increasing prover time).
Protocols based on univariate polynomials allow us to do multilinear evaluation in $O(n\log n)$ prover time (see e.g. Section 5 of \cite{logupgkr}), with constant proof size.
Choose a parameter $t$ and set $b=2^t$.
We can run \emph{only the first $t$ rounds} of \gemini, reaching a restricted multilinear on $n-t$ variables.
If $n'=n/(2^t)\leq n/\log n$, we can now apply a univariate protocol running in $O(n' \log n')$ time, running 
This still doesn't take us to overall constant proof size - as we  need to use a super-constant $t$ to reach such $n'$. (For us $t=\log n/2$ will be optimal, although $t\geq \log \log n$ suffices here.)


% Here comes the second idea.
This raises the question - can we ``skip'' the intermediate \gemini rounds and send \emph{only} the commitment $\cm_t$, and prove it is consistent with the original \cm?
Extrapolating the \gemini strategy in the natural way, we get the answer - yes, but not with constant proof size:
We can decompose $f$ into $b$ polynomials of degree $<n/b$: $f(X)=\sum_{0\leq i <b} X^i f_i(X^b)$.
As in the $b=2$ case, one can show the univariate $f'(X)$ corresponding to $M_t$ will be a linear combination
of the \set{f_i(X)}. Moreover, evaluating the $f_i$ using $f$ (for the consistency check) can be done.
However, it requires $b$ evaluations of $f$. Specifically,
$f_i$ at $(r^b)$ can be evaluated using $f$ at $\set{r,r\omega,\ldots,r\omega^{t-1}}$ for a primitive $t$'th root of unity $\omega$.


Our central innovation is a different way to prove $\cm_t$ is correct \emph{with} constant proof size.
Take any $\alpha \in \F$, and let $g(X)=f(X) \mod X^b-\alpha$.
Then,
\[g(X)= \sum_{0\leq i < b} X^i f_i(\alpha)\]
The restricted polynomial we are interested in
\[f'(X) = \sum_{0\leq i < b} \eq(i,u_1)f_i(X)\]

Proving correctness of $g$ can be done via a quotient. What remains is to connect $g$ and $f'$.
We can use KZG \cite{kzg} to get $f'(\alpha)=\sum_{0\leq i < b} \eq(i,u_1)f_i(X)$.
Now we can get the same evaluation  via evaluating $g$ as a mulitlinear!
\paragraph{Comparison to sumcheck}
It is instructive to see what  happens if we try to get a similar result via a modification of the sumcheck protocol \cite{lfkn}.
Note first that indeed a multilinear evaluation can be seen as a sum over the the committed function multiplied by the \eq function:
$$ \hat{f}(u) = \sum_{b \in B_n} \eq(b, u) \hat{f}(b). $$


The classic sumcheck protocol, like \gemini, works by $\log n$ reductions of the domain size by a factor of two; each round fixing one more variable of the summed function. In the above spirit, we could look at a modified sumcheck protocol, where the first variable ranges over a domain of super-constant size $b$. The first round univariate $P_1$ would thus have degree $2b$ in our case. We can send a  commitment to it rather than its coefficients as usually done to maintain constant proof size.
However, \emph{computing} $P_1$ would require superlinear time  $O(n \log b)$ - as we need to perform a $b$-size FFT for $n/b$ values of the second variable appearing in the sum. 


% 
% 
% 
% 
% Define $f_{u}=f_0+u\cdot f_1$. We think of $f_u$ as a ``folding'' 
% of $f$. Then \mle{f_u}
% is exactly the restriction $\mle{f}(u_1,X_2,\ldots,X_{\log n}$.
% 
% Recall that an MLE evaluation claim can be written in terms of a sumcheck over the values of the MLE over the boolean cube, weighted by the \eq function:
% $$ \hat{f}(u) = \sum_{b \in B_n} \hat{eq}(b, u) \hat{f}(b). $$
% 
% This allows us to generically reduce the problem of MLE evaluation to a degree $2$ sumcheck protocol.
% There are many different protocols for sumchecks, which roughly break down into two families.
% \begin{itemize}
% \item The first includes the univariate Arora sumcheck \cite{aurora}, incremental sumcheck \cite{}, and inner product protocols.
% These protocols all yield constant sized proofs, but require multiplying encodings of $\hat{f}$ and $\hat{eq}$ as univariate polynomials.
% This requires $O(N \log N)$ time.
% 
% \item 
% The other family of protocols are inspired by the classical sumcheck protocol. The idea
% from which these evaluation claims typically arise.
% In these protocols, the vectors are incrementally folded in half in linear time, resulting in an overall linear running time because $n/2 + n/4 + ... = O(n).$
% Commitments to these folded vectors are sent to the verifier, resulting in a logarithmically sized proof.
% This family includes both Zeromorph and Gemini\cite{zeromorph,gemini}.
% 
% However, these two families of protocols exist as extremes in a spectrum of sumcheck protocols, parameterized by a sequence of $(n_1, ..., n_k)$ such that $\prod_{i=1}^k n_i = n.$
% In these protocols, rather than folding by a factor of $2$ over $n$ rounds, or by a factor of $n$ over $1$ rounds, they are folded by the factors $n_i$ over $i$ rounds.
% Heuristically, we expect folding a vector of length $n$ by a factor of $n_1$ to take $O(n \log n_1)$ time.
% 
% \end{itemize}
% 
% 
% Let $f$ be our function.
% Our starting point, which is common, is viewing a multilinear evaluation as a sum of  over the boolean cube
% 
% We wish to use the idea that a multilinear evaluation 
% 


\section{Preliminaries}
\subsection{Terminology and conventions}\label{sec:terminology}
We work with integer parameter $n$ that we'll assume throughout the paper  is of the form
$n=2^{2t}$ for integer $t>0$. We'll denote its square root by $b\defeq 2^t=\sqrt{n}$.
We index vectors starting from zero. For example, for $g\in \F^b$ we have $g=(g_0,\ldots,g_{b-1})$.
We associate vectors with univariate polynomials in the following natural way:
Given $g\in \F^b$ we denote $g(X)\defeq \sum_{0\leq i < b} g_i X^i$.

We make the convention that integer ranges in sums begin at zero if not specified otherwise. Thus, we write
$g(X)=\sumi{b}g_i X^i$.

We assume vectors of size $n$ are indexed by two indices ranging over $\set{0,\ldots,b-1}$. Thus, for $f\in \F^n$, we have $f=(f_{0,0},\ldots,f_{0,b-1},\ldots,f_{b-1,0},\ldots,f_{b-1,b-1})$.
Accordingly, for $0\leq i <b$, we denote by $f_i$ the vector $(f_{i,0},\ldots, f_{i,b-1})$.

In particular, for $f\in \F^n$ we have under these notations that
\[f(X)\defeq \sumi{b}X^i f_i(X^b) = \sumi{b}\sumj{b}f_{i,j}X^{i+j\cdot b}\]
 

\subsection{Multilinear polynomials}\label{sec:multilin-polys}
Let $n=2^{2t}$.
We define the well-known \eq multilinear polynomial in $4t$ variables. 
\[\eq(x,y) \defeq \prodt ( x_i y_i + (1-x_i)(1-y_i))\]
We have for $x,y \in \B{2t}$, $\eq(x,y)=1$ when $x=y$ and $\eq(x,y)=0$ otherwise.

We use the convention that an integer $0\leq i < n$ can be used as an input to \eq by interpreting $i$ as its binary representation.
Namely, for $0\leq i <n$, $u\in \F^t$, $\eq(i,u)\defeq \eq(i_1,\ldots, i_t,u)$ where $i=\sum_{j\in [t]} i_j 2^{j-1}$.

For $a\in \F^n$, we define $\mle{f}$ to be the multilinear polynomial obtaining $f$'s values on the boolean cube.
Namely,
\[\mle{a}(X_1,\ldots,X_t) \defeq \sumi{n}\eq(i,X_1,\ldots,X_t)\cdot a_i.\]




\subsection{The algebraic group model}\label{subsec:agm}
We introduce some terminology from \cite{plonk} to capture analysis in the Algebraic Group Model of Fuchsbauer, Kiltz and Loss\cite{AGM}.

In our protocols, by an \emph{algebraic adversary} \adv in an SRS-based protocol we mean a \poly-time algorithm which satisfies the following.
\begin{itemize}
 \item For $i\in \set{1,2}$, whenever \adv outputs an element $A\in \Gi$, it also outputs a vector $v$ over \F such that $A = <v,\srsi>$.
\end{itemize}

First we say our \srs \emph{has degree $Q$} if all elements of \srsi are of the form  \enci{f(x)} for $f\in \polysofdeg{Q+1}$ and uniform $x\in \F$. In the following discussion let us assume we are executing a protocol with a degree $Q$ SRS, and denote by $f_{i,j}$ the corresponding polynomial for the $j$'th element of \srsi.

Denote by $a,b$ the vectors of $\F$-elements whose encodings in $\G1,\G2$ an algebraic adversary \adv outputs during a protocol execution; e.g., the $j$'th $\G1$ element output by \adv is \enc{a_j}.

By a ``real pairing check'' we mean a check of the form
\[(a\cdot T_1) \cdot (T_2\cdot b)=0\]
for some matrices $T_1,T_2$ over $\F$.
Note that such a check can indeed be done efficiently given the encoded elements and the pairing function $e:\G1\times \G2\to \Gt$.



Given such a ``real pairing check'', and the adversary \adv and protocol execution during which the elements were output, define the corresponding ``ideal check'' as follows.
Since \adv is algebraic when he outputs \enci{a_j} he also outputs a vector $v$ such that, from linearity, $a_j = \sum v_\ell f_{i,\ell}(x)=R_{i,j}(x)$ for $R_{i,j}(X) \defeq \sum v_\ell f_{i,\ell}(X)$.
Denote, for $i\in \set{1,2}$ the vector of polynomials $R_i=(R_{i,j})_j$.
The corresponding ideal check, checks as a polynomial identity whether
\[(R_1 \cdot T_1)\cdot (T_2\cdot R_2) \equiv 0\]


The following lemma is inspired by \cite{AGM}'s analysis of \cite{Groth16},
and tells us that for soundness analysis against algebraic adversaries it suffices to look at ideal checks.
Before stating the lemma we define the $Q$-DLOG assumption similarly to \cite{AGM}.
\begin{dfn}\label{ref:qdlog}
 Fix integer $Q$. The \emph{$Q$-DLOG assumption for $(\G1,\G2)$} states that given 
 \[\enc{1},\enc{x},\ldots,\enc{x^Q},\enctwo{1},\enctwo{x},\ldots,\enctwo{x^Q}\]
 for uniformly chosen $x\in \F$, the probability of an efficient \adv outputting $x$
 is \negl.
\end{dfn}



\begin{lemma}\label{lem:AGManalysis}
Assume the $Q$-DLOG for $(\G1,\G2)$.
 Given an algebraic adversary \adv participating in a protocol with a degree $Q$ SRS,
 the probability of any real pairing check passing is larger by at most an additive \negl factor than the probability the corresponding ideal check holds.
\end{lemma}
See \cite{plonk} for the proof.






\subsection{Polynomial commitment schemes for multilinear polynomials}

\begin{dfn}\label{dfn:PCscheme}
Let $n=2^t$. A multi-linear polynomial commitment scheme (ml-PCS) consists of 
\begin{itemize}
 \item $\gen(n)$ -  a randomized algorithm that outputs an SRS \srs0.
 \item $\com(f,\srs)$ - that given a polynomial $f\in \F^n$ returns a commitment \cm to $f$.
 \item A public coin protocol  $\open(\cm,n,u,v)$ between parties \prv and \ver. \prv is given $ f\in \F^n$. \prv and \ver are both given integer $n$, \cm - the purported commitment to $f$, $u\in \F^t$ and $v\in \F$ - the purported value $\mle{f}(u)$.
\end{itemize}
such that
\begin{itemize}
 \item \textbf{Completeness:} 
 Suppose that , $\cm = \com(f,\srs)$.  Then if \open is run correctly with values
 $n, \cm,u,v=\mle{f}(u)$, \ver outputs \acc with probability one.
 \item \textbf{Knowledge soundness in the algebraic group model:} There exists an efficient \ext such that for any algebraic adversary \adv the probability of \adv winning the following game is \negl over the randomness of \adv and \gen.
 \begin{enumerate}
  \item Given \srs, \adv outputs $n,\cm$.
  \item \ext, given access to the messages of \adv during the previous step, outputs $f\in \F^n$.
  \item \adv outputs $ u\in \F^t$, $v \in \F$.
  \item \adv takes the part of \prv in the protocol \open with inputs
  $n,\cm,u,v$.
  \item $\adv$ wins if 
  \begin{itemize} 
   \item \ver outputs \acc at the end of the protocol.
   \item $\mle{f}(u)\neq v$.
  \end{itemize}

 \end{enumerate}

\end{itemize}
\end{dfn}

\section{Components}
In this section we go over known components (with some new optimizations), that will be used in our main protocol in the next section. 
\subsection{Inner products in $O(b\log b)$ time.}
For polynomials $g_1(X)=\sum_{i=0}^{d_1} a_i X^i,g_2=\sum_{i=0}^{d_2} b_i X^i$ in $\polys$.
We define $<g_1,g_2>$ to be $\sum_{i=0}^d a_i b_i$ where $d\defeq \min \set{d_1,d_2}$. 
We present the following protocol to verify $<g_1,g_2>$ as 
A convenient way to get inner products in monomial similar to \cite{bootle,sonic}.


\paragraph{Batching inner product checks}

If we wish to show that $<g_1,g_2>=v_1$ and $<h_1,h_2>=v_2$. 
\begin{enumerate}
 \item 
\ver  chooses random $\gamma \in \F$
\item \prv sends $S\in \polys$ such that 
\[ g_1(X)g_2(1/X)+ g_1(X) g_2(1/X) + \gamma(h_1(X)h_2(1/X) + h_1(1/X)h_2(X)) = 2(v_1+\gamma v_2) + X\cdot S(X)\]
\end{enumerate}
\subsection{Multi-liner evaluations as inner products of univariate polynomials.}
For $u\in \B{t}$ define the polynomial $\eqpol{u} = \sumi{b}\eq(i,u)X^i$.
Thus, we have for $g\in \polysofdeg{b}$, $\mle(g)=<g,\eqpol{u}>$.

A verifier 
Inner products.

\subsection{Degree checks}
This is based on Thakur \cite{thakur}.

\subsection{Batching}
Common practice to obtain an inner product of tw

Degree checks 

\section{Univariate division}

\begin{claim}\label{clm:univariatemod}
 Fix integers $b>0$ and let $n=b^2$. Fix $\alpha\in \F$, and $f(X)\in \polysofdeg{n}$.
Let $f_0(X),\ldots,f_{b-1}(X)\in \polysofdeg{b}$ be such that
$f(X)=\sumi{b}X^i f_i(X^b)$.
 Let $g(X)\in \polysofdeg{b},q(X)\in \polys$ be such that 
 \[f(X)=(X^b-\alpha)\cdot q(X) + g(X).\]
 Then,
 \begin{enumerate}
  \item $g(X)=\sumi{b} X^i f_i(\alpha)$.
  \item The coefficients of $q(X)$ can be computed in $O(n)$ \F-operations.
 \end{enumerate}

\end{claim}
\begin{proof}
To see the first item, note that reduction $\mod X^b-\alpha$ corresponds to substituting $\alpha$ into $X^b$ inside each $f_i(X^b)$ in the expression $\sumi{b}X^i f_i(X^b)$.
We proceed to the computation of $q(X)$.
 We compute for each $0\leq i <b$, the coefficients of the quotient $q_i(X)\in \polys$ such that
\[f_i(X)=q_i(X)(X-\alpha)+ f_i(\alpha).\]
 Using Horner's method for division by the linear polynomial $X-\alpha$ this requires only $n$ multiplications and additions in \F.
Now, we have that
\[f(X)=\sumi{b}X^i f_i(X^b) = \sumi{b} X^i \left(q_i(X^b)(X^b-\alpha)+f_i(\alpha)\right)= q(X)(X^b-\alpha) + g(X),\]
for $q(X)\defeq \sumi{b}X^i q_i(X^b)$.
Thus, the coefficients of $q(X)$ are simply the interleaving of the coefficients of the \set{q_i(X)}.
\end{proof}


\section{Main Construction}
\mercury is the tuple $(\gen,\com,\open)$ described next. \\    

\noindent
\underline{$\gen(n)$:}
Choose random $x\in \F$ and outputs \set{\enc{1},\enc{x},\ldots,\enc{x^{n-1}},\enctwo{1},\enctwo{x}}\\

\noindent
\underline{$\com(n,f,\srs)$:}
 Output $\sumi{b}\sumj{b}f_{i,j}\cdot \enc{x^{i\cdot b + j}}$.\\ \\ 

\noindent
\underline{$\open(n,\cm,u,v;f)$:} \\ \noindent
\begin{enumerate}
 \item \textsf{Committing to partial sums:} \ 
\begin{enumerate}
 \item \prv computes the polynomial to $h(X)\defeq \sumi{b}\eq(i,u_1) f_i(X)$. Note that the coefficient of $X^j$ in $h(X)$ is $\sumi{b}\eq(i,u_1) f_{i,j}$ - hence we think of it as a commitment to partial sums. 
 \item \prv computes and sends $\h\defeq\enc{h(x)}$.
 
 \end{enumerate}
\item \textsf{ Committing to  ``folded'' polynomial $g$:} 
\begin{enumerate}
 \item \ver sends random $\alpha \in \F$.
\item \prv computes polynomials $g(X) \in \polysofdeg{b}$ and $q(X)\in \polys$ such that
\[f(X)=(X^b-\alpha)\cdot q(X) + g(X).\]\label{step:modalpha}
\item \prv computes and sends $\q\defeq \enc{q(x)}$ and $\g\defeq \enc{g(x)}$.

\end{enumerate}

\item  \textsf{Sending proofs of correctness for $h$ and the degree of $g$:} 
\begin{enumerate}
\item \ver sends a random batching challenge $\gamma \in \F$.
\item \prv computes and sends $\s=\enc{S(x)}$ where $S(X)\in \F[X]$ is  such that
\[g(X)\eqpol{u_1}(1/X) + g(1/X)\eqpol{u_1}(X)+ \gamma\cdot ( h(X)\eqpol{u_2}(1/X) + h(1/X)\eqpol{u_2}(X) )\]
\[  =h(\alpha) +\gamma \cdot v+X\cdot S(X)+(1/X)S(1/X).\]
\item \prv computes and sends $\d\defeq \enc{D(x)}$ where 
\[D(X)\defeq X^{b-1} g(1/X).\]
\end{enumerate}
\item  \textsf{KZG evaluations:} 
\begin{enumerate}
\item  \ver sends a random evaluation challenge $\zeta \in \F$.
\item \prv sends the values $\fzeta\defeq f(\zeta),\qzeta \defeq q(\zeta), \gzeta \defeq g(\zeta), \ginv \defeq g(1/\zeta), \hzeta \defeq h(\zeta), \hinv \defeq h(1/\zeta), \halpha\defeq h(\alpha),\szeta \defeq s(\zeta),\sinv\defeq s(1/\zeta),\dzeta\defeq D(\zeta)$.\label{step:evals}
\item \ver sends a random KZG batching challenge $\eta\in \F$.
\item \prv computes and sends the KZG opening proof  \prfzeta for the values \fzeta and \qzeta. That is $\prfzeta \defeq \enc{H(x)}$ for
\[H(X) \defeq \frac{f(X)-f(\zeta) +\eta(q(X)-q(\zeta))}{X-\zeta}.\]
\item \prv computes and send a batched KZG opening proof \prfother for the rest of the values  sent in step \ref{step:evals}, as described in Section 4 of \cite{shplonk}.
\item \ver checks the proof \prfzeta as in \cite{kzg}:\label{step:checkfirst}
   \[e(\cm-\enc{\fzeta} + \eta(\q -\enc{\qzeta}),\enctwo{1})=e(\prfzeta,\enctwo{x}).\]
   \item \ver checks the opening proof \prfother as described in \cite{shplonk}.
   \item \ver checks the equation

\[\gzeta \eqpol{u_1}(1/\zeta) + \ginv \eqpol{u_1}(\zeta) + \gamma(\hzeta \eqpol{u_2}(1/\zeta) + \hinv \eqpol{u_2}(\zeta))= \halpha +\gamma v + \zeta \szeta + (1/\zeta)\sinv.\]   
\item \ver checks the equation $\dzeta=\zeta^{b-1} \ginv$.\label{step:checklast}
\item If one of the checks in steps \ref{step:checkfirst}-\ref{step:checklast} fails \ver outputs \rej. Otherwise \ver outputs \acc.

\end{enumerate}
\end{enumerate}

\paragraph{Runtime of \prv:}
Computing $q(X)$ in step \ref{step:modalpha} requires $O(n)$ operations by Claim \ref{clm:univariatemod}.
Computing $\q$ and $\prfzeta$ requires two MSMs of size $n$. All other steps are on polynomials of size $O(b)=O(\sqrt{n})$.
\paragraph{Proving knowledge soundness:}

Let \adv be an efficient algebraic adversary participating in the Knowledge Soundness game from
Definition \ref{dfn:lookupprot}.
We show its probability of winning the game is \negl.
Let $f\in \polysofdeg{\tabsize}$ be the polynomial sent by \adv in the third step of the game
such that $\cm=\enc1{f(x)}$.
As \adv is algebraic, when sending the commitments \m,\a,\b,\p,\qa,\qb,\gamproof,\zerproof during protocol execution it also sends polynomials $m(X),A(X),B_0(X),$ $P(X),Q_A(X),Q_B(X),h(X),A_0(X)\in \polysofdeg{\tabsize}$ such that the former are their corresponding commitments.
Let $E$ be the event that \ver outputs \acc.
Note that the event that \adv wins the knowledge soundness game is contained in $E$. 
$E$ implies all pairing checks have passed.
Let $A\subset E$ be the event that one of the corresponding ideal pairing checks as defined in Section \ref{subsec:agm} didn't pass.
According to Lemma \ref{lem:AGManalysis}, $\prob(A)=\negl$.
\bibliographystyle{alpha}
\bibliography{references}
\end{document}

